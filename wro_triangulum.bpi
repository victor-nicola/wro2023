@kp = 0.5
@kd = 0.1
@left_motor = "B"
@right_motor = "C"
@wheel_diameter = 6.24 '6.24
@wheel_diameterSpecial = 6.1
@robot_diameter = 17.2 '-0.35 cm
@white = 75' de modificat 67'nu folosim
@grey = 40' de modificat 30
@grey_rb = 30
@black = 10' de modificat 10'nu folosim
@Stop_motor = @left_motor + @right_motor
@acceleration_encoder = 400
@deceleration_encoder = 500
@speed_0 = 20
@wheel2sensor_distance = 8.9
@maxRed = 219
@maxGreen = 197
@maxBlue = 155
@global = 0
@MaximumWhiteSensor1=75' de modificat
@MaximumWhiteSensor2=85' de modificat
@TimeBetween = 300
@degA = 0
@degD = 0
@auxD = 0
@auxA = 0
@kpD = 0.5
@optimumval = 69
@contor_error = 5
@stegulet_pervers = 0

Function debugcitire(out number hue,out number sat)
  Sensor.SetMode(3,4)
  red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
EndFunction

Sub ultimaSecventa
  @kpD = 1
  @degD = 126 'am pus alba pe nava mare
  wait_claw()
  resetClaw()
  lowerLiftToBigShip() 'apuc nava mare
  closeClawForSpeciala() 'am apucat-o
  @kpD = 1
  @degD = 135 'ridic putin sa nu ma blochez cu gumele
  reverseMoveSyncCM(7, @speed_movesync + 10, "off", "off", "on") 'inapoi pe linie
  RobotSpin("right",90, 60, "off", "off", "off")
  Program.Delay(200)
  lf_cm(80, 20,"off","off","on")
  @degA = 0
  @degD = 0 'ridic tot sa imping cu senzorii
  lf_cm(100, 120,"on","off","on")
  
  @kpD = 1  
  @degD = 140 'cobor gheara ca sa fim projection (tiganeasca de la galati)
  
  Motor.MoveSync("BC", -30, 60, 650, "True") 'facem un fel de arc ca sa intram in box
  LCD.Clear()
  LCD.Write(20,20,Time.Get3())
EndSub

Function CircleDegToMotorDeg( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameter
EndFunction

Function circleDegToMotorDegForRotation( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameterSpecial
EndFunction

Function MotorDegToCircleDeg( in number motorDeg, out number deg )
  deg = motorDeg * @wheel_diameter / @robot_diameter
EndFunction

Function Cm2Degrees(in number cm,out number degrees)
  degrees = (360*cm) / (Math.Pi*@wheel_diameter)
EndFunction

Sub Claw

  While(1 > 0 )
   
    encoderA = Motor.GetCount("A")
    errorA = @degA - encoderA
    PA = errorA * @kpA
    DA = (errorA - error_oldA) * @kdA
    error_oldA = errorA
    Motor.StartPower("A",PA + DA)
    
    encoderD = Motor.GetCount("D")
    errorD = @degD - encoderD
    PD = errorD * @kpD
    DD = (errorD - @error_oldD) * @kdD
    @error_oldD = errorD
    speedD = PD + DD
    if(speedD < -100) Then
      speedD = -100
     EndIf
    Motor.StartPower("D",speedD)
    
    'if @stegulet = 1 Then
      'vectorSpeed[limit] = speedD
      'limit = limit + 1
    'EndIf
    
    'LCD.Text(1, 10, 10, 1, speedD)
    
    'if Math.Remainder(pasi,50) = 0 Then
      'LCD.Clear()
      'LCD.Text(1, 10, 10, 1, speedD)
      'pasi = pasi + 1
    'EndIf
    
    'if(err1 < 10 And err1 > -10 And err2 < 10 And err2 > -10 )Then
      '@stegulet_pervers = 0
    'EndIf
    'if((degD > 170 AND @auxD > 170 ) OR (degA > 170 And @auxA > 170 ))Then
      '@stegulet_pervers = 0
    'EndIf    
  EndWhile
EndSub

'A motor mediu de prindere
'D motor mare de invartire

sub luare2Cuburi
@degA = 80
@kpD = 0.2
@degD = 180
wait_claw_specific(700) 
@kpA = 0.2
@degA = 500 'inchidem clawu'era 300
wait_claw_specific(1000)'era 300
@kpA = 0.8
@degA = 100
wait_claw_specific(400)
@kpA = 0.2
@degA = 500 
wait_claw_specific(1000)'era 300
@kpA = 0.5
@degA = 400 'apucam cuburile
wait_claw_specific(300)
reverseMoveSyncCM(2, @speed_movesync, "off", "off", "on") 'ne dam in spate sa nu dam in zid
@kpD = 0.4
@degD = 180
wait_claw_specific(800)
@kpD = 5
@kdD = 10
@degD = 110
'ridicam cuburile
wait_claw()
wait_claw()
EndSub


sub closeFor2Cubes
  @kpA = 0.2
  @degA = 300
  @degD  = 200
  wait_claw_specific(300)
  @degD  = 165
  @degA = 140
  wait_claw()
  @kpA = 0.5
  @degA = 500
  wait_claw_specific(300)
EndSub

Sub wait_claw
  Time.Reset1()
  @stegulet_pervers = 1
  While Time.Get1() < @TimeBetween' And @stegulet_pervers = 1
    
  EndWhile
EndSub

Function wait_claw_specific(in number timp)
  Time.Reset1()
  While Time.Get1() < timp
    
  EndWhile
EndFunction

sub raiseLift
  @kpD = 5
  @degD = 120
  wait_claw()
EndSub

sub raiseLiftsuper
  @kpD = 5
  @degD = 110
  wait_claw()
EndSub

Sub lowerLift
  @kpD = 0.6
  @degD = 160'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

sub lowerLiftToBigShip
  @kpD = 0.6 '0.6
  @degD = 200 '167
  wait_claw()
  wait_claw()
EndSub

Sub closeClaw
  @kpA = 0.2
  @degA = 400
  wait_claw() 
EndSub

Sub closeClawForSpeciala
  @kpA = 0.5 '5
  @kdA = 10
  @degA = 400
  wait_claw() 
  @kdA = 0.1
EndSub

sub resetClaw
  @kpA = 0.8
  @degA = 0
  wait_claw()
  @kpA = 0.2
EndSub

sub letALittle
  @degA = 125
  wait_claw()
  wait_claw()
EndSub

sub letALittleMedium
  @kpA = 1
  @degA = 137
  wait_claw()
EndSub

sub putGreenOnShip
  @kpD = 0.6
  @degD = 138
  wait_claw()
  wait_claw()
 letALittleMedium()
EndSub

sub putGreenOnSmallShip
  @kpD = 0.8
  @degD = 138
  wait_claw()
  @degA = 130
EndSub

Function ceSaUrmaresti(in number case, in number a, in number b, in number c, in number d, out number follow)
  'case
  '1 - 2 verde
  '2 - 2 albastru
  '3 - mixt
  follow = -1
  If case = 1 Then
    If b = 3 And c = 3 Then
      follow = 1
    Else 
      If c = 3 And d = 3 Then
        follow = 0
      Else 
        If a = 3 And b = 3 Then
          follow = 2
        EndIf
      EndIf
    EndIf
  Else 
    If case = 2 Then
      If b = 2 And c = 2 Then
        follow = 1
      Else 
        If c = 2 And d = 2 Then
          follow = 0
        Else
          If a = 2 And b = 2 Then
            follow = 2
          EndIf
        EndIf
      EndIf
    Else 
      If case = 3 Then
        If a + b = 5 Then
          follow = 2              
        Else 
          If c + d = 5 Then
            follow = 0
          Else   
            If b + c = 5 Then
              follow = 1    
            EndIf
          EndIf
        EndIf
      EndIf  
    EndIf
  EndIf
EndFunction

Function stangadreata(in number cm, in number v, in string sens)
  
  robot_diameter = 17.25
  decc = "off"
  if v > 0 Then
    decc  = "on"
  EndIf
  
  gr = Math.ArcCos((1 - (cm / robot_diameter))) * (robot_diameter / @wheel_diameter) * (180 / Math.Pi)
  MotorDegToCircleDeg(gr,codex)
  if sens = "left" Then
    spinDegrees(v, "right",codex, "off", decc, "on")
    Program.Delay(100)
    spinDegrees(v, "left",codex, "off", decc, "on")
    Program.Delay(100)

  Else
    spinDegrees(v, "left",codex, "off", decc, "on")
    Program.Delay(100)
    spinDegrees(v, "right",codex, "off", decc, "on")
    Program.Delay(100)
  EndIf
  
EndFunction

Function LF_Encoder_1sensor(in number encoder_cm, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
  
  Sensor.SetMode(1, 0)
  '------ These values might be adjusted for light or speed
  AcceleratedEncoder = 200
  DeceleratedEncoder = 300
  black = 5
  grey = 30
  V0 = 20
  kp = 1
  kd = 0.1
  '------
  error_old = 0
  exit_condition = 1
  Motor.ResetCount("BC")
  
  Cm2Degrees(encoder_cm, encoder)
  

  
  While exit_condition = 1
    
    'read the sensors only one time in the loop!
    s1 = Sensor.ReadPercent(1)
    CurrentEncoder = Motor.GetCount("C")
    
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
      
      If V > Vmax Then
        V = Vmax
      EndIf
      
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
    
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
        
        If V < 20 Then
          V = 20
        EndIf
        
      EndIf
    EndIf
    
    error = grey - s1
      
    'PD controller for linefollower
    P = kp * error
    D = kd * (error - error_old)
    MotorB = -1 * ( V + (P + D) )
    MotorC = V - (P + D)
    error_old = error
    
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
    
    'exit condition for line follower: encoder
    If CurrentEncoder > encoder Then
      exit_condition = 0
    EndIf
    
  EndWhile
  
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    Motor.Stop("BC", "True")
  EndIf
EndFunction

Function LF_Encoder_1sensorTillWhite(in number encoder_cm, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
  
  Sensor.SetMode(1, 0)
  Sensor.SetMode(2, 0)
  '------ These values might be adjusted for light or speed
  AcceleratedEncoder = 200
  DeceleratedEncoder = 300
  black = 5
  grey = 30
  V0 = 20
  kp = 1
  kd = 0.1
  '------
  error_old = 0
  exit_condition = 1
  Motor.ResetCount("BC")
  
  Cm2Degrees(encoder_cm, encoder)
  

  
  While exit_condition = 1
    
    'read the sensors only one time in the loop!
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    if s2 > 36 then 
      exit_condition = 0
    EndIf
    
      CurrentEncoder = Motor.GetCount("C")
    
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
      
      If V > Vmax Then
        V = Vmax
      EndIf
      
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
    
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
        
        If V < 20 Then
          V = 20
        EndIf
        
      EndIf
    EndIf
    
    error = grey - s1
      
    'PD controller for linefollower
    P = kp * error
    D = kd * (error - error_old)
    MotorB = -1 * ( V + (P + D) )
    MotorC = V - (P + D)
    error_old = error
    
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
    
    'exit condition for line follower: encoder
    If CurrentEncoder > encoder Then
      exit_condition = 0
    EndIf
    
  EndWhile
  
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    Motor.Stop("BC", "True")
  EndIf
EndFunction

Function lf_intersection(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_intersection_read_col(in number speed_max,in string acceleration,in string deceleration,in string end_brake,out number type)
  Cm2Degrees(8.5,prim_st) '3.5 +6.5
  Cm2Degrees(10.5,prim_dr)'6
  Cm2Degrees(13.5,doi_st)'8.5
  Cm2Degrees(15.7,doi_dr)'10.5
  
  frec[360] = 0
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  deg = current_encoder
  
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(6,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1 
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    
    if((current_encoder+deg>=prim_st AND current_encoder+deg<=prim_dr) OR (current_encoder+deg>=doi_st AND current_encoder+deg<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  'handle = EV3File.OpenWrite("vectorfrecventa.txt")
  'i = 0
  final = " "
  'While i < 100
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 200
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 300
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 360
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)

EndFunction

Function lf_cm_read_col(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake,out number type)
  Cm2Degrees(8.5,prim_st)
  Cm2Degrees(11,prim_dr)
  Cm2Degrees(13.5,doi_st)
  Cm2Degrees(15.5,doi_dr)
  
  frec1[360] = 0
  frec2[360] = 0
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    
    if(current_encoder>=prim_st AND current_encoder<=prim_dr)Then
      citire(hue)
      frec1[hue] = frec1[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    ElseIf(current_encoder>=doi_st AND current_encoder<=doi_dr)Then
      citire(hue)
      frec2[hue] = frec2[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else    
      EV3.SetLEDColor("GREEN","NORMAL")     
    EndIf
    
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  
  type=2 'albastru * 2
  contor = 0 
  for i=121 to 168' verde
    contor = contor + frec1[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 3'albastru + verde
  EndIf     
  contor = 0 
  for i=121 to 168'verde
    contor = contor + frec2[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf    
  
EndFunction

Function lf_cm(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_cm_cu_cub(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  kp = 0.25
  kd = 0.5
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_cm_cu_nava(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  kp = 1
  kd = 0.5
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function RobotSpin(in string direction,in number degrees,in number speed,in string acceleration, in string deceleration, in string end_brake)  
  kp = 0.5
  kd = @kd
  ki = 0.01
  V0 = @speed_0
  if direction = "left" Then
    side = 1
  else 
    side = -1
  EndIf
  
  'left is side = 1 and right is side = -1
  '------

  '------
  errorOld = 0
  '------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  circleDegToMotorDegForRotation(degrees, encoder)
  
  
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 250
  If 0.25 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.25 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  
  exit = 0
  err_sum = 0
  While exit <> 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    currentEncoder = (Math.Abs(r1) + Math.Abs(r2)) / 2
    'r1 is the left engine, and r2 is the right engine
    error = Math.Abs(r2) - Math.Abs(r1)
    P = kp * error
    D = kd * (error - errorOld)
    I = ki * err_sum
    errorOld = error
    err_sum = err_sum + error
    
    'LCD.Clear()
    'LCD.Text(0, 1, 1, 2, currentEncoder)
    'LCD.Update()
    
    V = speed
    If acceleration = "on" AND  currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (speed - V0) + V0
      If V > speed Then
        V = speed
      EndIf
    EndIf
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        'Speaker.Tone(70, 5000, 100)
        V = ((encoder - currentEncoder) / decelerationEncoder) * (speed - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf  
    
    
    motorB = V + (P + D + I)
    motorC = V - (P + D + I)
    
    If exit <> 1 Then
      Motor.StartPower( "B", motorB * side )
      Motor.StartPower( "C", motorC * side )
    EndIf
    
    'errorLast = error
    If currentEncoder >= encoder Then
      exit = 1
    EndIf
   
  EndWhile
 
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  'Program.Delay(200)
 
EndFunction

Function MoveSyncAcc(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  kp = 0.5
  kd = @kd
  ki = 0.01
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  error_sum = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    P = kp * error
    D = kd * (error - error_old)
    I = ki * error_sum
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D + I)))
    Motor.StartPower(@right_motor,(speed - (P + D + I)))
    error_sum = error_sum + error
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function spinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  
  ' ----------
  v0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  encoder = circleDegrees * 2 * 17.9 / @wheel_diameter
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 200
  If 0.2 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.2 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  While exitCondition = 1
   
    r1 = Motor.GetCount(@left_motor)
    r2 = Motor.GetCount(@right_motor)
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    V = Vmax
    If acceleration = "on" AND currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (Vmax - V0) + V0
      If V > Vmax Then
        V = Vmax
      EndIf
    EndIf
    If deceleration = "on" Then
      If currentEncoder >= encoder - decelerationEncoder Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (Vmax - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf
    
    If side = "right" Then
      Motor.StartPower("C", V)
    Else
      Motor.StartPower("B", V * -1)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
  EndWhile
 
  If endBrake = "on" Then
    Motor.Stop("BC", "True")
  Else
    Motor.Stop("BC", "False")
  EndIf
 
EndFunction

Function reverseSpinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  ' ----------
  V0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  diam = 17.7
  if ( side = "right" ) Then
    diam = 17.5
  EndIf
  ' ----------
  encoder = circleDegrees * 2 * diam / @wheel_diameter
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 200
  If 0.2 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.2 * encoder
  EndIf
 
  Motor.ResetCount("BC")
 
  While exitCondition = 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    If currentEncoder < accelerationEncoder Then
      If acceleration = "on" Then
        V = (currentEncoder / accelerationEncoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier increases as the robot gets closer to the acceleration quota
      Else
        V = Vmax  
      EndIf
    EndIf
    If encoder - currentEncoder < decelerationEncoder Then
      If deceleration = "on" Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier decreases as the robot gets closer to the deceleration quota
      Else
        V = Vmax
      EndIf
    EndIf
   
    If side = "right" Then
      Motor.StartPower("C", V * -1)
    Else
      Motor.StartPower("B", V)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
  EndWhile
 
  If endBrake = "on" Then
    Motor.Stop("BC", "True")
  Else  
    Motor.Stop("BC", "False")
  EndIf
EndFunction

Function citire(out number col)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
EndFunction

Function citire2(out number col,out number saturation,out number value)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
  saturation = sat
  value = val
  
EndFunction

Function MoveTillBlack(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 < @grey And s2 < @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function MoveTillWhite(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 > @grey And s2 > @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function StraightAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSyncAcc(@speed_movesync,0.5,"on", "on", "on") '--------------------------

EndFunction

Function reverseMoveSyncCM(in number distance, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  V0 = @speed_0
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  If encoder > 1000 Then
    
    AcceleratedEncoder = @acceleration_encoder
    DeceleratedEncoder = @deceleration_encoder
    
  Else
    
    AcceleratedEncoder = encoder * 0.1
    DeceleratedEncoder = encoder * 0.1
    
  EndIf
  
  Motor.ResetCount("BC")
 
  While exit_condition = 1
   
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C") * (-1)
    CurrentEncoder = s2
   
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
     
      If V > Vmax Then
        V = Vmax
      EndIf
     
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
   
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
       
        If V < V0 Then
          V = V0
        EndIf
       
      EndIf
    EndIf
   
    'PD controller for sync movement
   
    error = s1 + s2 'AM TE GAND SA OMOR UN COPIL COPAC ________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = -1 * (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
 
EndFunction

Function reverseMoveSyncCM_read(in number distance, in number V, in string end_brake,out number cubu1,out number cubu2,out number cubu3,out number cubu4)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  
  Motor.ResetCount("BC")
  Cm2Degrees(3, dist)
  Cm2Degrees(3.5, deg1)
  Cm2Degrees(10.5, deg2)
  Cm2Degrees(17.5, deg3)
  Cm2Degrees(25, deg4)
  Cm2Degrees(0, offset)
  v1[360] = 0
  v2[360] = 0
  v3[360] = 0
  v4[360] = 0
  stop1 = 0
  stop2 = 0
  stop3 = 0
  stop4 = 0
  start1 = 0
  start2 = 0
  start3 = 0
  start4 = 0
  Sensor.SetMode(3, 4)
  While exit_condition = 1
    
    
    
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C")
    CurrentEncoder = s2
    citire(col)
    if Math.Abs(CurrentEncoder) >= deg1 + offset and Math.Abs(CurrentEncoder) <= deg1 + dist + offset Then  
      'if(stop1 = 0)Then
        'stop1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v1[col]=v1[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg2 + offset and Math.Abs(CurrentEncoder) <= deg2 + dist + offset Then  
      'if(stop2 = 0)Then
        'stop2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v2[col]=v2[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg3 + offset and Math.Abs(CurrentEncoder) <= deg3 + dist + offset Then
      'if(stop3 = 0)Then
        'stop3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v3[col]=v3[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg4 + offset and Math.Abs(CurrentEncoder) <= deg4 + dist + offset Then
      'if(stop4 = 0)Then
        'stop4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v4[col]=v4[col]+1
    'Else 
       'if(start1 = 0 AND stop1 = 1)Then
        'start1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start2 = 0 AND stop2 = 1)Then
        'start2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start3 = 0 AND stop3 = 1)Then
        'start3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start4 = 0 AND stop4 = 1)Then
        'start4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
    EndIf  
   
    
    
    'PD controller for sync movement
   
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", -MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v1[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v1[i]
  EndFor   
  if(contor > 0)Then
    cubu1 = 3
  Else    
    cubu1 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v2[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v2[i]
  EndFor   
  if(contor > 0)Then
    cubu2 = 3
  Else    
    cubu2 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v3[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v3[i]
  EndFor   
  if(contor > 0)Then
    cubu3 = 3
  Else    
    cubu3 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v4[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v4[i]
  EndFor   
  if(contor > 0)Then
    cubu4 = 3
  Else     
    cubu4 = 2  
  EndIf
 
EndFunction

Function RotateTillWhite(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var=1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 > @grey + 20)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 > @grey + 20)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  Motor.Stop("BC","true")
EndFunction

Function RotateTillBlack(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var = 1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 < @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 < @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  'Motor.Stop(@Stop_motor,"true")
  'Program.Delay(100)
  'Time.Reset1()
  'time = 300
  'error = 0
  'error_old = 0
  'error_sum = 0
  'kp = 1
  'kd = 0.1
  'ki = 0.0001
  'exit_condition = 1

  'While exit_condition = 1
    's1 = sensor.ReadPercent(1)
    's2 = sensor.ReadPercent(2)
    's1=(s1/@MaximumWhiteSensor1)*100
    's2=(s2/@MaximumWhiteSensor2)*100
    'error = s1 - s2
    'P = kp * error
    'D = kd * (error - error_old)
    'I = ki * error_sum
    'Motor.StartPower(@left_motor,-((P + D + I)))
    'Motor.StartPower(@right_motor,-((P + D + I)))
    'error_old = error
    'error_sum = error_sum + error
    'If Time.Get1() > time Then
      'exit_condition = 0
    'EndIf
  'EndWhile
  
  Motor.Stop("BC","true")
EndFunction

Function PerfectLine(in number speed,in string direction)
  'Program.Delay(2000)
  RotateTillWhite(speed,direction)
  'Program.Delay(2000)
  RotateTillBlack(speed,direction)
EndFunction

Function ArcMove(in number radius, in number degrees, in number speed, in string direction)
  encoder = 2 * (radius + @robot_diameter / 2) / @wheel_diameter * degrees
  
  if(direction = "right")Then
    speedLeft = speed * -1
    speedRight = speed * (radius - @robot_diameter / 2) / (radius + @robot_diameter / 2)
  Else
    speedRight = speed 
    speedLeft = -1 * speed * (radius - @robot_diameter / 2) / (radius + @robot_diameter / 2)
  EndIf      
  
  Motor.MoveSync("BC", speedLeft, speedRight, encoder, "on")
  
EndFunction  

Function lf_intersection_cu_cub(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.25
  kd = 0.5
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey And s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction