@kp = 0.5
@kd = 0.1
@left_motor = "B"
@right_motor = "C"
@wheel_diameter = 6.24
@robot_diameter = 17.25 '-0.5 cm 
@white = 60' de modificat
@grey = 30' de modificat
@grey_rb = 30
@black = 9' de modificat
@Stop_motor = @left_motor + @right_motor
@acceleration_encoder = 400
@deceleration_encoder = 300
@speed_0 = 20
@wheel2sensor_distance = 9
@maxRed = 229
@maxGreen = 226
@maxBlue = 175
@global = 0
@MaximumWhiteSensor1=79' de modificat
@MaximumWhiteSensor2=83' de modificat
@TimeBetween = 300
@degA = 0
@degD = 0
@kpD = 0.5
@optimumval = 69
@contor_error = 5

Function CircleDegToMotorDeg( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameter
EndFunction

Sub Claw
  error_oldA = 0
  kpA = 0.3
  kdA = 0.1
  error_oldD = 0
  @kpD = 0.5
  kdD = 0.1
  @degA = 0
  @degD = 0
  Motor.ResetCount("DA")
  While(1 = 1)
    encoder = Motor.GetCount("A")
    error = degA - encoder
    PA = error * kpA
    DA = (error - error_oldA) * kdA
    error_oldA = error
    Motor.StartPower("A",PA + DA)
    encoder = Motor.GetCount("D")
    error = degD - encoder
    PD = error * kpD
    DD = (error - error_oldD) * kdD
    error_oldD = error
    Motor.StartPower("D",PD + DD)
  EndWhile
EndSub

'A motor mediu de prindere
'D motor mare de invartire

Sub wait_claw
  Time.Reset1()
  While Time.Get1() < @TimeBetween
  EndWhile
EndSub

sub raiseLift
  @kpD = 5
  @degD = 130
  wait_claw()
EndSub

Sub lowerLift
  @kpD = 0.6
  @degD = 200'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

Sub lowerLiftSpecialCube
  @kpD = 0.6
  @degD = 152
  wait_claw()
EndSub

Sub lowerLiftSpecialCubePut
  @kpD = 4
  @degD = 145'se coboara(*urca acum ca suntem smecheri) la unghiul optim ca sa punem speciala
  wait_claw()
EndSub

sub lowerLiftToLittleShip
  @kpD = 0.5
  @degD = 190
  wait_claw()
  wait_claw()
  wait_claw()

EndSub

sub resetLift
  @kpD = 0.5
  @degD = 0
  wait_claw()
EndSub

Sub prepLowerLiftSpecialCube
  @degA = -120
  wait_claw()
EndSub

Sub closeClaw
  @degA = -250
  wait_claw()
  @degA = -500 ' de modificat
EndSub

sub resetArm
  @degA = 0
  @degD = 10
  wait_claw()
EndSub

sub resetClaw
  @degA = 0
  wait_claw()
EndSub

sub prepForWhite
  @degA = -120
  wait_claw()
  @kpD = 0.6
  @degD = 180'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

Sub prepForGreen1
  @degA = -130
  wait_claw()
EndSub

Sub prepForGreen
  @degA = -125
  wait_claw()
EndSub

sub letALittle
  @degA = -130
  wait_claw()
  wait_claw()
EndSub

sub letALittleless
  @degA = -135
  wait_claw()
  wait_claw()
EndSub

sub putGreenOnShip
  @kpD = 0.6
  @degD = 145
  wait_claw()
  wait_claw()
 letALittleless()
EndSub

sub putWhiteOnShip
  @kpD = 0.6
  @degD = 130
  wait_claw()
  wait_claw()
  wait_claw()
  letALittleless()
EndSub

sub putGreenOnSmallShip
  @kpD = 0.8
  @degD = 140
  wait_claw()
  wait_claw()
  letALittleless()
EndSub

sub putWhiteOnSmallShip
  @kpD = 0.6
  @degD = 140
  wait_claw()
  wait_claw()
  wait_claw()
  wait_claw()
  wait_claw()
  letALittle()
EndSub

Function ceSaUrmaresti(in number case, in number a, in number b, in number c, in number d, out number follow)
  'case
  '1 - 2 verde
  '2 - 2 albastru
  '3 - mixt
  follow = -1
  If case = 1 Then
    If b = 3 And c = 3 Then
      follow = 1
    Else 
      If c = 3 And d = 3 Then
        follow = 0
      EndIf
    Else 
      If a = 3 And b = 3 Then
        follow = 2
      EndIf
    EndIf
  Else 
    If case = 2 Then
      If b = 2 And c = 2 Then
        follow = 1
      Else 
        If c = 2 And d = 2 Then
          follow = 0
        EndIf
      Else
        If a = 2 And b = 2 Then
          follow = 2
        EndIf
      EndIf
    EndIf
  Else 
    If case = 3 Then
      If b + c = 5 Then
        follow = 1              
      Else 
        If c + d = 5 Then
          follow = 0
        EndIf                
      Else 
        If a + b = 5 Then
          follow = 2
        EndIf
      EndIf
    EndIf
  EndIf
EndFunction

Function stangadreata(in number cm, in number v, in string sens)
  
  gr = Math.ArcCos((1 - (cm / @robot_diameter))) * 2 * (@robot_diameter / @wheel_diameter) * (180 / Math.Pi)
  if sens = "left" Then
    Motor.Move("C", v, gr, "True")
    Program.Delay(100)
    Motor.Move("B", -v, gr, "True")
    Program.Delay(100)
  Else
    Motor.Move("B", -v, gr, "True")
    Program.Delay(100)
    Motor.Move("C", v, gr, "True")
    Program.Delay(100)
  EndIf
  
EndFunction

Function lf_intersection(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_intersection_read_col(in number speed_max,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  Cm2Degrees(3.5,prim_st)
  Cm2Degrees(6,prim_dr)
  Cm2Degrees(8.5,doi_st)
  Cm2Degrees(10.5,doi_dr)
  
  frec[360] = 0
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  deg = current_encoder
  
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(6,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1 
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    
    if((current_encoder+deg>=prim_st AND current_encoder+deg<=prim_dr) OR (current_encoder+deg>=doi_st AND current_encoder+deg<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  'handle = EV3File.OpenWrite("vectorfrecventa")
  'i = 0
  'final = " "
  'While i < 100
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 200
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 300
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 360
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)

EndFunction

Function lf_cm_read_col(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  Cm2Degrees(8.5,prim_st)
  Cm2Degrees(11,prim_dr)
  Cm2Degrees(13.5,doi_st)
  Cm2Degrees(15.5,doi_dr)
  
  frec[360] = 0
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")     
    EndIf
    
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  
EndFunction

Function lf_cm(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function Cm2Degrees(in number cm,out number degrees)
  degrees = (360*cm) / (Math.Pi*@wheel_diameter)
EndFunction

Function RobotSpin(in string direction,in number degrees,in number speed,in string acceleration, in string deceleration, in string end_brake)
  if direction = "left" Then
    side = 1
  else 
    side = -1
  EndIf
  
  'left is side = 1 and right is side = -1
  '------
  kp = 1
  kd = 0
  V0 = 20
  '------
  errorOld = 0
  '------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  circleDegToMotorDeg(degrees, encoder)
  
  accelerationEncoder = 0.2 * encoder
  decelerationEncoder = 0.5 * encoder
 
  Motor.ResetCount("BC")
  
  exit = 0
  While exit <> 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    currentEncoder = (Math.Abs(r1) + Math.Abs(r2)) / 2
    'r1 is the left engine, and r2 is the right engine
    error = Math.Abs(r1) - Math.Abs(r2)
    P = kp * error
    D = kd * (error - errorOld)
    errorOld = error
    
    LCD.Clear()
    LCD.Text(0, 1, 1, 2, currentEncoder)
    LCD.Update()
    
    V = speed
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (speed - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    ElseIf acceleration = "on" Then
      V = (currentEncoder / accelerationEncoder) * (speed - V0) + V0
      If V > speed Then
        V = speed
      EndIf
    EndIf
    
    motorB = V + (P + D)
    motorC = V + (P + D)
    
    If exit <> 1 Then
      Motor.StartPower( "B", -motorB )
      Motor.StartPower( "C", -motorC )
    EndIf
    
    'errorLast = error
    If currentEncoder >= encoder Then
      exit = 1
    EndIf
   
  EndWhile
 
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  'Program.Delay(200)
 
EndFunction

Function Rotation2Black(in string direction,in number speed,in string end_break)
  Sensor.SetMode(1,0)
  sensor.SetMode(2,0)
  If direction = "right" Then
    s2 = sensor.ReadPercent(2)
    While s2 > @grey_rb
      Motor.StartSync(@Stop_motor,-speed,-speed)
      s2 = sensor.ReadPercent(2)
    EndWhile
    Motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s1 - s2
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,-((P + D + I)))
      Motor.StartPower(@right_motor,-((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  Else
    s1 = sensor.ReadPercent(1)
    While s1 > @grey_rb
      Motor.StartSync(@Stop_motor,speed,speed)
      s1 = sensor.ReadPercent(1)
    EndWhile
    motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s2 - s1
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,((P + D + I)))
      Motor.StartPower(@right_motor,((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  EndIf
EndFunction

Function MoveSync(in number speed_max,in number cm,in string end_brake)
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function ReactiveBreakingPerversaDeStanga(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], 100 * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile
  'Motor.Stop("BC", "True")
EndFunction

Function ReactiveBreakingPerversaDeDreapta(in number vit)
  port[0] = "C"
  port[1] = "B"
  side = 1
  mult = -1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], 100 * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile
  'Motor.Stop("BC", "True")
EndFunction


Function ReactiveBreaking(in string sideString)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  if sideString = "right" Then
    side = 1
    mult = -1
  EndIf
  
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 150 
    Motor.StartPower(port[1 - side], 100 * mult)
    Motor.StartPower(port[side], 100 * mult)
    timer = Time.Get5()
  EndWhile
  
  Motor.Stop(port[1 - side], "True")
  while enc * mult < 150
    Motor.StartPower(port[side], 100 * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], 100 * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
  
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], 100 * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile
EndFunction

Function spinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  
  ' ----------
  v0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  encoder = circleDegrees * 2 * @robot_diameter / @wheel_diameter
  Motor.ResetCount("BC")
  While exitCondition = 1
   
    r1 = Motor.GetCount(@left_motor)
    r2 = Motor.GetCount(@right_motor)
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    If currentEncoder < @acceleration_encoder Then
     
      If acceleration = "on" Then
        V = (currentEncoder / @acceleration_encoder) * (Vmax - v0) + v0
        V = Math.Abs(V)
        'multiplier increases as the robot gets closer to the acceleration quota
      Else
        V = Vmax  
      EndIf
     
    EndIf
   
    If encoder - currentEncoder < @deceleration_encoder Then
     
      If deceleration = "on" Then
        V = ((encoder - currentEncoder) / @deceleration_encoder) * (Vmax - v0) + v0
        V = Math.Abs(V)
        'multiplier decreases as the robot gets closer to the deceleration quota
      Else
        V = Vmax
      EndIf
     
    EndIf
   
    If side = "right" Then
      Motor.StartPower("C", V)
    Else
      Motor.StartPower("B", V * -1)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
   
  EndWhile
 
  If endBrake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else
    
    Motor.Stop("BC", "False")
  
  EndIf
 
EndFunction

Function reverseSpinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  ' ----------
  V0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  encoder = circleDegrees * 2 * diamAx / diamRoata
 
 
  Motor.ResetCount("BC")
 
  While exitCondition = 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    If currentEncoder < @acceleration_encoder Then
     
      If acceleration = "on" Then
        V = (currentEncoder / @acceleration_encoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier increases as the robot gets closer to the acceleration quota
      Else
        V = Vmax  
      EndIf
     
    EndIf
   
    If encoder - currentEncoder < @deceleration_encoder Then
     
      If deceleration = "on" Then
        V = ((encoder - currentEncoder) / @deceleration_encoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier decreases as the robot gets closer to the deceleration quota
      Else
        V = Vmax
      EndIf
     
    EndIf
   
    If side = "right" Then
      Motor.StartPower("C", V * -1)
    Else
      Motor.StartPower("B", V)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
   
  EndWhile
 
  If endBrake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
EndFunction

Function citire(out number col)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
EndFunction

Function MoveTillBlack(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 < @grey or s2 < @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function MoveTillWhite(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 > @grey or s2 > @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function StraightAlley(in number speed)
  MoveTillWhite(speed,"true")
  MoveTillBlack(speed,"true")
EndFunction

Function GayAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSync(70, 3, "on")
EndFunction

Function reverseMoveSyncCM(in number distance, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  V0 = @speed_0
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  If encoder > 1000 Then
    
    AcceleratedEncoder = @acceleration_encoder
    DeceleratedEncoder = @deceleration_encoder
    
  Else
    
    AcceleratedEncoder = encoder * 0.1
    DeceleratedEncoder = encoder * 0.1
    
  EndIf
  
  Motor.ResetCount("BC")
 
  While exit_condition = 1
   
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C") * (-1)
    CurrentEncoder = s2
   
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
     
      If V > Vmax Then
        V = Vmax
      EndIf
     
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
   
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
       
        If V < V0 Then
          V = V0
        EndIf
       
      EndIf
    EndIf
   
    'PD controller for sync movement
   
    error = s1 + s2
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = -1 * (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
 
EndFunction


Function reverseMoveSyncCM_read(in number distance, in number V, in string end_brake,out number cubu1,out number cubu2,out number cubu3,out number cubu4)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  
  Motor.ResetCount("BC")
  Cm2Degrees(2, dist)
  Cm2Degrees(3, deg1)
  Cm2Degrees(10, deg2)
  Cm2Degrees(17, deg3)
  Cm2Degrees(24.5, deg4)
  v1[360] = 0
  v2[360] = 0
  v3[360] = 0
  v4[360] = 0
  Sensor.SetMode(3, 4)
  While exit_condition = 1
    
    
    
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C") * (-1)
    CurrentEncoder = s2
    citire(col)
    if Math.Abs(CurrentEncoder) >= deg1 and Math.Abs(CurrentEncoder) <= deg1 + dist Then  
      v1[col]=v1[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg2 and Math.Abs(CurrentEncoder) <= deg2 + dist Then  
      v2[col]=v2[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg3 and Math.Abs(CurrentEncoder) <= deg3 + dist Then  
      v3[col]=v3[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg4 and Math.Abs(CurrentEncoder) <= deg4 + dist Then  
      v4[col]=v4[col]+1
    EndIf  
   
    'PD controller for sync movement
   
    error = s1 + s2
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = -1 * (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v1[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v1[i]
  EndFor   
  if(contor > 0)Then
    cubu1 = 3
  Else    
    cubu1 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v2[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v2[i]
  EndFor   
  if(contor > 0)Then
    cubu2 = 3
  Else    
    cubu2 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v3[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v3[i]
  EndFor   
  if(contor > 0)Then
    cubu3 = 3
  Else    
    cubu3 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v4[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v4[i]
  EndFor   
  if(contor > 0)Then
    cubu4 = 3
  Else     
    cubu4 = 2  
  EndIf
 
EndFunction

Function RotateTillWhite(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var=1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 > @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 > @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  Motor.Stop("BC","true")
EndFunction

Function RotateTillBlack(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = 1
    sens = 2
  Else   
    var=-1  
    sens = 1
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 < @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 < @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  
  Motor.Stop(@Stop_motor,"true")
  Time.Reset1()
  time = 300
  error = 0
  error_old = 0
  error_sum = 0
  kp = 1
  kd = 0.5
  ki = 0.0001
  exit_condition = 1
  While exit_condition = 1
    s1 = sensor.ReadPercent(1)
    s2 = sensor.ReadPercent(2)
    s1=(s1/@MaximumWhiteSensor1)*100
    s2=(s2/@MaximumWhiteSensor2)*100
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    I = ki * error_sum
    Motor.StartPower(@left_motor,-((P + D + I)))
    Motor.StartPower(@right_motor,-((P + D + I)))
    error_old = error
    error_sum = error_sum + error
    If Time.Get1() > time Then
      exit_condition = 0
    EndIf
  EndWhile
  
  Motor.Stop("BC","true")
EndFunction

Function PerfectLine(in number speed,in string direction)
  RotateTillWhite(speed,direction)
  RotateTillBlack(speed,direction)
EndFunction