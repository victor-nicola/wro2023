@kp = 0.5
@kd = 0.1
@left_motor = "B"
@right_motor = "C"
@wheel_diameter = 6.24 '6.24
@wheel_diameterSpecial = 6.1
@robot_diameter = 17.2 '-0.35 cm
@white = 75' de modificat 67
@grey = 15' de modificat 30
@grey_rb = 30
@black = 10' de modificat 10
@Stop_motor = @left_motor + @right_motor
@acceleration_encoder = 400
@deceleration_encoder = 500
@speed_0 = 20
@wheel2sensor_distance = 8.9
@maxRed = 229
@maxGreen = 226
@maxBlue = 175
@global = 0
@MaximumWhiteSensor1=75' de modificat
@MaximumWhiteSensor2=85' de modificat
@TimeBetween = 300
@degA = 0
@degD = 0
@auxD = 0
@auxA = 0
@kpD = 0.5
@optimumval = 69
@contor_error = 5
@stegulet_pervers = 0

sub checkpoint
  lf_cm_cu_cub(@speed_lf,16,"off","off","on")
  RobotSpin("right",4, @speed_spin, "on", "on", "on") 'ma pozitionez cand las cuburile pe small ship sa nu fac buba
  @kpD = 0.8
  @degD = 140
  wait_claw()
  @kpA = 0.5
  @degA = 130 'mission accomplished
  wait_claw()
  @kpD = 1
  @degD = 90
  wait_claw()
  RobotSpin("right",4, @speed_spin, "on", "on", "on")
  @degA = 0
  @kpD = 0.2
  @degD = 300
  wait_claw()
  wait_claw()
  wait_claw()
  closeClawForSpeciala()
  wait_claw()
  @kpD = 1
  @degD = 140
  ArcMove(12, 90, -100, "right") 'terminam arcu inainte de intersectia cu nava mica
  lf_cm_cu_cub(70,10, "off","off","on")
  @degA = 0
  wait_claw_specific(100)
  @kpD = 1
  @degD = 90
  lf_cm_cu_cub(80,30, "off","off","off")
  lf_intersection(80, "off", "on", "on")
  reverseMoveSyncCM(7, @speed_movesync, "off", "off", "on")
  RobotSpin("left",140, @speed_spin, "off", "on", "on") 'ca sa luam speciala
  @kpD = 0.8
  resetClaw()
  MoveSyncAcc(@speed_movesync,5,"on", "on", "on") '--------------------------
  @kpD = 0.6
  @degD = 160
  wait_claw_specific(250)
  closeClawForSpeciala() 'am luat speciala
  @kpD = 5
  @degD = 100
  reverseMoveSyncCM(7, @speed_movesync + 30, "off", "off", "on")
  RobotSpin("right",135, @speed_spin, "off", "on", "off") 'inapoi pe linie
  lf_cm(80,10,"on","off","off")
  lf_intersection(80, "off", "off", "on")
  MoveSyncAcc(50,15,"on", "on", "on") '----------------------------
  reverseMoveSyncCM(6, @speed_movesync, "off", "off", "on")
  RobotSpin("right",90, @speed_spin, "on", "on", "on")
  'PerfectLine(30, "right") 'cu fata catre crane
  @kpD = 4
  @degD = 138 'punem gheara la unghiu bun
  lf_cm(@speed_lf,15,"on","off","off") 'activam punem speciala
  @degA = 0
  @degD = 0
  lf_cm(@speed_lf,10,"off","off","on") 'activam craneu
  Time.Reset7()
  While(Time.Get7() < 250)
    Motor.StartSync("BC", -60, 60)
  EndWhile
  reverseMoveSyncCM(10, 30, "off", "off", "off")
  ArcMove(22, 90, -70, "right")
  RobotSpin("left",170, @speed_spin, "on", "on", "on") 'sunt pe linie
  PerfectLine(30, "left") 
   'termin arcmoveu pe linie dupa intersectie
  lf_cm(80,70,"on","off","off")
  lowerLift()
  lf_intersection(80, "off", "on", "on")
  closeClaw() 'iau alba
  raiseLift()
  lf_cm(80,13,"off","off","off")
  lf_intersection(80, "off", "on", "on")
  RobotSpin("right",90, @speed_spin, "on", "on", "on") 'cu fata la nava mare
  
  MoveSyncAcc(@speed_movesync,6,"on", "on", "on") '--------------------
  
  ultimaSecventa()
EndSub

Sub ultimaSecventa
  putWhiteOnShip() 'am pus alba pe nava mare
  raiseLift()
  resetClaw()
  lowerLiftToBigShip() 'apuc nava mare
  closeClawForSpeciala() 'am apucat-o
  @kpD = 1
  @degD = 140
  reverseMoveSyncCM(8, @speed_movesync + 10, "off", "off", "on")
  RobotSpin("right",90, 70, "off", "off", "off")
  Program.Delay(200)
  lf_cm(80, 20,"off","off","on")
  @degA = 0
  @degD = 0
  lf_cm(100, 120,"on","off","on")
  
  'RobotSpin("left",10, @speed_spin, "on", "on", "on") 'ne pozitionam catre stanga ca sa intram in box
  
  @kpD = 1  
  @degD = 140
  'wait_claw_specific(1)
  'Motor.MoveSync("BC", -60, 100, 400, "True") 'facem un fel de arc ca sa intram in box
  Motor.MoveSync("BC", -30, 60, 600, "True")
  LCD.Clear()
  LCD.Write(20,20,Time.Get3())
EndSub

Function CircleDegToMotorDeg( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameter
EndFunction
Function circleDegToMotorDegForRotation( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameterSpecial
EndFunction

Function MotorDegToCircleDeg( in number motorDeg, out number deg )
  deg = motorDeg * @wheel_diameter / @robot_diameter
EndFunction

Sub Claw
  error_oldA = 0
  @kpA = 0.3
  @kdA = 0.1
  error_oldD = 0
  @kpD = 1
  @kdD = 10
  @degA = 0
  @degD = 0
  Motor.ResetCount("DA")
  While(1 = 1)
    if Buttons.Current = "U" Then
      resetClaw()
    EndIf
    encoder = Motor.GetCount("A")
    error = degA - encoder
    err1 = degA - encoder
    @auxA = encoder
    PA = error * kpA
    DA = (error - error_oldA) * kdA
    error_oldA = error
    Motor.StartPower("A",PA + DA)
    encoder = Motor.GetCount("D")
    error = degD - encoder
    err2 = degD - encoder
    @auxD = encoder
    PD = error * kpD
    DD = (error - error_oldD) * kdD
    error_oldD = error
    Motor.StartPower("D",PD + DD)
    if(err1 < 10 And err1 > -10 And err2 < 10 And err2 > -10 )Then
      @stegulet_pervers = 0
    EndIf
    if((degD > 170 AND @auxD > 170 ) OR (degA > 170 And @auxA > 170 ))Then
      @stegulet_pervers = 0
    EndIf    
  EndWhile
EndSub

'A motor mediu de prindere
'D motor mare de invartir

sub closeFor2Cubes
  kpA = 0.2
  @degA = 300
  degD  = 200
  wait_claw_specific(300)
  degD  = 165
  degA = 140
  wait_claw()
  @kpA = 0.3
  @degA = 500
  wait_claw_specific(300)
EndSub


Sub wait_claw
  Time.Reset1()
  @stegulet_pervers = 1
  While Time.Get1() < @TimeBetween' And @stegulet_pervers = 1
    
  EndWhile
EndSub

Function wait_claw_specific(in number timp)
  Time.Reset1()
  While Time.Get1() < timp
    
  EndWhile
EndFunction

Sub wait_claw_but_slower
  Time.Reset1()
  @stegulet_pervers = 1
  While Time.Get1() < @TimeBetween
    
  EndWhile
EndSub

sub prepForTwoCubes
  @degA = 130
  wait_claw()
  wait_claw()
  wait_claw()
EndSub

sub raiseLift
  @kpD = 5
  @degD = 120
  wait_claw()
EndSub

sub raiseLiftLittle
  @kpD = 5
  @degD = 145
  wait_claw()
EndSub

sub raiseLiftalittle
  @kpD = 5
  @degD = @auxD-10
  wait_claw()
EndSub

sub aslowaspossible
  @kpD = 0.3
  @degD = 200
  wait_claw()
  wait_claw()
EndSub

sub raiseLiftsuper
  @kpD = 5
  @degD = 110
  wait_claw()
EndSub

Sub lowerLift
  @kpD = 0.6
  @degD = 160'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

Sub lowerLiftslow
  @kpD = 0.4
 @degA = 90
  wait_claw()
  wait_claw()
  wait_claw()
EndSub

Sub lowerLiftsLowAndLower
  @kpD = 0.6
  @degD = 200
  wait_claw()

EndSub

sub lowerLiftFor2Cubes
  @kpD = 0.6
  @degD = 160 '175 '300
  wait_claw()
  wait_claw()
EndSub

Sub lowerLiftSpecialCube
  @kpD = 0.6
  @degD = 153
  wait_claw()
EndSub

Sub lowerLiftSpecialCubePut
  @kpD = 4
  @degD = 137 'se coboara(*urca acum ca suntem smecheri) la unghiul optim ca sa punem speciala
  wait_claw()
EndSub

sub lowerLiftToLittleShip
  @kpD = 0.4
  @degD = 190
  wait_claw()
  wait_claw()
  wait_claw()

EndSub

sub lowerLiftToBigShip
  @kpD = 0.6 '0.6
  @degD = 200 '167
  wait_claw()
  wait_claw()
  wait_claw()
EndSub

sub destroyFlagLittleShipOne
  @kpD = 0.5
  @degD = 110
  wait_claw()
  wait_claw()  
  'wait_claw()  
  'wait_claw()   
EndSub

sub destroyFlagLittleShipTwo
  @kpD = 1
  @degD = 143
  '@degA = 80
  wait_claw()  
  wait_claw()  
  wait_claw()  
  'wait_claw()  
  'wait_claw()  
  'RobotSpin("right",30 ,100, "off", "off", "off")
  'RobotSpin("left",30 ,100, "off", "off", "on")  
EndSub

sub resetLift
  @kpD = 0.5
  @degD = 0
  wait_claw()
EndSub

Sub prepLowerLiftSpecialCube
  @degA = -120
  wait_claw()
EndSub

Sub closeClaw
  @kpA = 0.2
  @degA = 400
  wait_claw() 
EndSub

Sub closeClawForSpeciala
  @kpA = 0.5 '5
  @kdA = 10
  @degA = 400
  wait_claw() 
  @kdA = 0.1
EndSub

sub resetArm
  @degA = 0
  @degD = 10
  wait_claw()
EndSub

sub resetClaw
  @degA = 0
  wait_claw()
EndSub

sub clawForWhite
  
  @degA = -110
  wait_claw()
  
EndSub

sub TakeTwoCubesUnderYou
  @kpD = 0.4
  @degD = 210
  wait_claw_specific(1000)
  @kdD = 10
  reverseMoveSyncCM(10, @speed_movesync - 30, "on", "on", "on")
  @kpD = 4
  @degD = 145
  wait_claw_specific(100)
  @kpA = 5
  @degA = 30
  wait_claw_specific(100)
  
  @degD = 170
  wait_claw_specific(400)
  
  @kpA = 5
  @degA = 250
  wait_claw_specific(300)
  raiseLift()  
EndSub

sub TakecubeUnderYou
  @kpD = 0.6
  @kdD = 50
  @kpA = 5
  @degA = 190
  @degD = 220
  wait_claw_specific(1000)
  @kdD = 10

  reverseMoveSyncCM(10, @speed_movesync - 30, "on", "on", "on")
  @kpD = 4
  @degD = 145
  wait_claw_specific(100)
  @kpA = 5
  @degA = 140
  wait_claw_specific(100)
  
  @degD = 170
  wait_claw_specific(400)
  
  @kpA = 5
  @degA = 250
  wait_claw_specific(300)
  raiseLift()
EndSub

sub prepForWhite
  @degA = 140
  wait_claw()
EndSub

Sub prepForGreen1
  @degA = 150
  wait_claw()
EndSub

Sub prepForGreen
  @degA = 125
  wait_claw()
EndSub

sub letALittleMore
  @degA = 115
  wait_claw()
  wait_claw()
EndSub

sub letALittle
  @degA = 125
  wait_claw()
  wait_claw()
EndSub

sub letALittleMedium
  @degA = 137
  wait_claw()
EndSub

sub letALot
  @degA = -80
  wait_claw()
  wait_claw()
EndSub

sub letALittleless
  @degA = 140
  wait_claw()
  wait_claw()
EndSub

sub putGreenOnShip
  @kpD = 0.6
  @degD = 140
  wait_claw()
  wait_claw()
 letALittleMedium()
EndSub

sub GreenCubeFall
  @kpD = 1
  @degD = 130
  wait_claw()
  wait_claw()
 resetClaw()
EndSub

sub putWhiteOnShip
  @kpD = 0.8
  @degD = 130
  wait_claw()
  letALittleMedium()
EndSub

sub putGreenOnSmallShip
  @kpD = 0.8
  @degD = 140
  wait_claw()
  @degA = 130
EndSub

sub putWhiteOnSmallShip
  @kpD = 0.6
  @degD = 140
  wait_claw()
  wait_claw()
  letALittle()
EndSub

Function ceSaUrmaresti(in number case, in number a, in number b, in number c, in number d, out number follow)
  'case
  '1 - 2 verde
  '2 - 2 albastru
  '3 - mixt
  follow = -1
  If case = 1 Then
    If b = 3 And c = 3 Then
      follow = 1
    Else 
      If c = 3 And d = 3 Then
        follow = 0
      Else 
        If a = 3 And b = 3 Then
          follow = 2
        EndIf
      EndIf
    EndIf
  Else 
    If case = 2 Then
      If b = 2 And c = 2 Then
        follow = 1
      Else 
        If c = 2 And d = 2 Then
          follow = 0
        Else
          If a = 2 And b = 2 Then
            follow = 2
          EndIf
        EndIf
      EndIf
    Else 
      If case = 3 Then
        If a + b = 5 Then
          follow = 2              
        Else 
          If c + d = 5 Then
            follow = 0
          Else   
            If b + c = 5 Then
              follow = 1    
            EndIf
          EndIf
        EndIf
      EndIf  
    EndIf
  EndIf
EndFunction

Function treiCaz(in number case, in number a, in number b, in number c, in number d, out number follow)
  'case
  '1 - 2 verde
  '2 - 2 albastru
  '3 - mixt
  follow = -1
  if( a == 4 - case AND c == 4 - case)Then
    follow = 4
  Else  
    if( b == 4 - case AND d == 4 - case)Then
      follow = 5
    EndIf      
  EndIf    
EndFunction

Function stangadreata(in number cm, in number v, in string sens)
  
  robot_diameter = 17.25
  decc = "off"
  if v > 0 Then
    decc  = "on"
  EndIf
  
  gr = Math.ArcCos((1 - (cm / robot_diameter))) * (robot_diameter / @wheel_diameter) * (180 / Math.Pi)
  MotorDegToCircleDeg(gr,codex)
  if sens = "left" Then
    spinDegrees(v, "right",codex, "off", decc, "on")
    Program.Delay(100)
    spinDegrees(v, "left",codex, "off", decc, "on")
    Program.Delay(100)

  Else
    spinDegrees(v, "left",codex, "off", decc, "on")
    Program.Delay(100)
    spinDegrees(v, "right",codex, "off", decc, "on")
    Program.Delay(100)
  EndIf
  
EndFunction

Function lf_intersection(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_intersection_read_col(in number speed_max,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  
  Cm2Degrees(8.5,prim_st) '3.5 +6.5
  Cm2Degrees(10.5,prim_dr)'6
  Cm2Degrees(13.5,doi_st)'8.5
  Cm2Degrees(15.7,doi_dr)'10.5
  
  frec[360] = 0
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  deg = current_encoder
  
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(6,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1 
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    
    if((current_encoder+deg>=prim_st AND current_encoder+deg<=prim_dr) OR (current_encoder+deg>=doi_st AND current_encoder+deg<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  'handle = EV3File.OpenWrite("vectorfrecventa.txt")
  'i = 0
  final = " "
  'While i < 100
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 200
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 300
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 360
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)

EndFunction

Function lf_cm_read_col(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  Cm2Degrees(8.5,prim_st)
  Cm2Degrees(11,prim_dr)
  Cm2Degrees(13.5,doi_st)
  Cm2Degrees(15.5,doi_dr)
  
  frec[360] = 0
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")     
    EndIf
    
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  
EndFunction

Function lf_cm(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_cm_cu_cub(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.25
  kd = 0.5
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function Cm2Degrees(in number cm,out number degrees)
  degrees = (360*cm) / (Math.Pi*@wheel_diameter)
EndFunction

Function RobotSpinGhearaJos(in string direction,in number degrees,in number speed,in string acceleration, in string deceleration, in string end_brake)  
  
  V0 = @speed_0
  if direction = "left" Then
    kp = 0.5
    kd = 0.1
    ki = 0.0005
    side = 1
  else 
    kp = 0.5
    kd = 0.5
    ki = 0.0001
    side = -1
  EndIf
  
  'left is side = 1 and right is side = -1
  '------

  '------
  errorOld = 0
  '------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  circleDegToMotorDegForRotation(degrees, encoder)
  
  
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 250
  If 0.25 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.25 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  
  exit = 0
  err_sum = 0
  While exit <> 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    currentEncoder = (Math.Abs(r1) + Math.Abs(r2)) / 2
    'r1 is the left engine, and r2 is the right engine
    error = Math.Abs(r2) - Math.Abs(r1)
    P = kp * error
    D = kd * (error - errorOld)
    I = ki * err_sum
    errorOld = error
    err_sum = err_sum + error
    
    LCD.Clear()
    LCD.Text(0, 1, 1, 2, currentEncoder)
    LCD.Update()
    
    V = speed
    If acceleration = "on" AND  currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (speed - V0) + V0
      If V > speed Then
        V = speed
      EndIf
    EndIf
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (speed - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf  
    
    
    motorB = V + (P + D + I)
    motorC = V - (P + D + I)
    
    If exit <> 1 Then
      Motor.StartPower( "B", motorB * side )
      Motor.StartPower( "C", motorC * side )
    EndIf
    
    'errorLast = error
    If currentEncoder >= encoder Then
      exit = 1
    EndIf
   
  EndWhile
 
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  'Program.Delay(200)
 
EndFunction

Function RobotSpin(in string direction,in number degrees,in number speed,in string acceleration, in string deceleration, in string end_brake)  
  kp = 0.5
  kd = @kd
  ki = 0.01
  V0 = @speed_0
  if direction = "left" Then
    side = 1
  else 
    side = -1
  EndIf
  
  'left is side = 1 and right is side = -1
  '------

  '------
  errorOld = 0
  '------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  circleDegToMotorDegForRotation(degrees, encoder)
  
  
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 250
  If 0.25 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.25 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  
  exit = 0
  err_sum = 0
  While exit <> 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    currentEncoder = (Math.Abs(r1) + Math.Abs(r2)) / 2
    'r1 is the left engine, and r2 is the right engine
    error = Math.Abs(r2) - Math.Abs(r1)
    P = kp * error
    D = kd * (error - errorOld)
    I = ki * err_sum
    errorOld = error
    err_sum = err_sum + error
    
    LCD.Clear()
    LCD.Text(0, 1, 1, 2, currentEncoder)
    LCD.Update()
    
    V = speed
    If acceleration = "on" AND  currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (speed - V0) + V0
      If V > speed Then
        V = speed
      EndIf
    EndIf
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        'Speaker.Tone(70, 5000, 100)
        V = ((encoder - currentEncoder) / decelerationEncoder) * (speed - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf  
    
    
    motorB = V + (P + D + I)
    motorC = V - (P + D + I)
    
    If exit <> 1 Then
      Motor.StartPower( "B", motorB * side )
      Motor.StartPower( "C", motorC * side )
    EndIf
    
    'errorLast = error
    If currentEncoder >= encoder Then
      exit = 1
    EndIf
   
  EndWhile
 
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  'Program.Delay(200)
 
EndFunction

Function Rotation2Black(in string direction,in number speed,in string end_break)
  Sensor.SetMode(1,0)
  sensor.SetMode(2,0)
  If direction = "right" Then
    s2 = sensor.ReadPercent(2)
    While s2 > @grey_rb
      Motor.StartSync(@Stop_motor,-speed,-speed)
      s2 = sensor.ReadPercent(2)
    EndWhile
    Motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s1 - s2
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,-((P + D + I)))
      Motor.StartPower(@right_motor,-((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  Else
    s1 = sensor.ReadPercent(1)
    While s1 > @grey_rb
      Motor.StartSync(@Stop_motor,speed,speed)
      s1 = sensor.ReadPercent(1)
    EndWhile
    motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s2 - s1
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,((P + D + I)))
      Motor.StartPower(@right_motor,((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  EndIf
EndFunction

'Function MoveSync(in number speed_max,in number cm,in string end_brake)
  'kp = @kp
  'kd = @kd
  'exit_condition = 1
  'Motor.ResetCount(@stop_motor)
  'left_encoder = 0
  'right_encoder = 0
  'Cm2Degrees(cm,encoder)
  'error_old = 0

  'While exit_condition = 1
    'left_encoder = Motor.GetCount(@left_motor)
    'right_encoder = Motor.GetCount(@right_motor)
    'current_encoder = ((-1*left_encoder) + right_encoder) / 2
    'error = left_encoder + right_encoder
    'P = kp * error
    'D = kd * (error - error_old)
    'speed=speed_max
    'Motor.StartPower(@left_motor,-(speed + (P + D)))
    'Motor.StartPower(@right_motor,(speed - (P + D)))
    'error_old = error
    'If current_encoder > encoder Then
      'exit_condition = 0
    'EndIf
  'EndWhile
  'If end_brake = "on" Then
    'Motor.Stop("BC","True")
  'EndIf
  
'EndFunction

Function MoveSyncAcc(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  kp = 0.5
  kd = @kd
  ki = 0.01
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  error_sum = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    P = kp * error
    D = kd * (error - error_old)
    I = ki * error_sum
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D + I)))
    Motor.StartPower(@right_motor,(speed - (P + D + I)))
    error_sum = error_sum + error
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function ReactiveBreakingPerversaDeStangaStraightAlley(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 200
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
  Motor.ResetCount(port[side])
  while enc < 150
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
  Sensor.SetMode(2-side, 0)
  s2 = Sensor.ReadPercent(2-side)
  while s2 < @grey
    Motor.StartPower(port[2-side], vit * mult)
    s2 = Sensor.ReadPercent(2-side)
  EndWhile
  
  Sensor.SetMode(side, 0)
  s1 = Sensor.ReadPercent(side)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side)
  EndWhile
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
 
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
EndFunction

Function ReactiveBreakingPerversaDeDreaptaStraightAlley(in number vit)
  port[0] = "C"
  port[1] = "B"
  side = 1
  mult = -1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 100 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
 
  
  'Sensor.SetMode(2 - side, 0)
  's2 = Sensor.ReadPercent(2 - side)
  'while s2 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's2 = Sensor.ReadPercent(2 - side)
  'EndWhile
  
  
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Motor.Stop("BC", "True")
EndFunction

Function ReactiveBreakingIntersectionCuburi(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 100
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  
  Motor.Stop(port[1 - side], "True")
  while enc < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 > @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile

EndFunction

Function ReactiveBreakingIntersectionStanga(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  
  Motor.Stop(port[1 - side], "True")
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
  
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile
EndFunction

Function ReactiveBreakingIntersectionDreapta(in number vit)
  port[0] = "C"
  port[1] = "B"
  side = 1
  mult = -1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 150
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
 
  
  'Sensor.SetMode(2 - side, 0)
  's2 = Sensor.ReadPercent(2 - side)
  'while s2 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's2 = Sensor.ReadPercent(2 - side)
  'EndWhile
  
  
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Motor.Stop("BC", "True")
EndFunction

Function spinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  
  ' ----------
  v0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  encoder = circleDegrees * 2 * 17.9 / @wheel_diameter
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 200
  If 0.2 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.2 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  While exitCondition = 1
   
    r1 = Motor.GetCount(@left_motor)
    r2 = Motor.GetCount(@right_motor)
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    V = Vmax
    If acceleration = "on" AND currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (Vmax - V0) + V0
      If V > Vmax Then
        V = Vmax
      EndIf
    EndIf
    If deceleration = "on" Then
      If currentEncoder >= encoder - decelerationEncoder Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (Vmax - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf
    
    If side = "right" Then
      Motor.StartPower("C", V)
    Else
      Motor.StartPower("B", V * -1)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
  EndWhile
 
  If endBrake = "on" Then
    Motor.Stop("BC", "True")
  Else
    Motor.Stop("BC", "False")
  EndIf
 
EndFunction

Function reverseSpinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  ' ----------
  V0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  diam = 17.7
  if ( side = "right" ) Then
    diam = 17.5
  EndIf
  ' ----------
  encoder = circleDegrees * 2 * diam / @wheel_diameter
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 200
  If 0.2 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.2 * encoder
  EndIf
 
  Motor.ResetCount("BC")
 
  While exitCondition = 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    If currentEncoder < accelerationEncoder Then
      If acceleration = "on" Then
        V = (currentEncoder / accelerationEncoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier increases as the robot gets closer to the acceleration quota
      Else
        V = Vmax  
      EndIf
    EndIf
    If encoder - currentEncoder < decelerationEncoder Then
      If deceleration = "on" Then
        V = ((encoder - currentEncoder) / decelerationEncoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier decreases as the robot gets closer to the deceleration quota
      Else
        V = Vmax
      EndIf
    EndIf
   
    If side = "right" Then
      Motor.StartPower("C", V * -1)
    Else
      Motor.StartPower("B", V)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
  EndWhile
 
  If endBrake = "on" Then
    Motor.Stop("BC", "True")
  Else  
    Motor.Stop("BC", "False")
  EndIf
EndFunction

Function citire(out number col)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
EndFunction

Function citire2(out number col,out number saturation,out number value)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
  saturation = sat
  value = val
  
EndFunction

Function MoveTillBlack(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 < @grey And s2 < @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function MoveTillWhite(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 > @grey And s2 > @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function StraightAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSyncAcc(@speed_movesync,0.5,"on", "on", "on") '--------------------------

EndFunction

Function GayAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSyncAcc(70, 3, "on", "on", "on") '----------------------------
EndFunction

Function reverseMoveSyncCM(in number distance, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  V0 = @speed_0
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  If encoder > 1000 Then
    
    AcceleratedEncoder = @acceleration_encoder
    DeceleratedEncoder = @deceleration_encoder
    
  Else
    
    AcceleratedEncoder = encoder * 0.1
    DeceleratedEncoder = encoder * 0.1
    
  EndIf
  
  Motor.ResetCount("BC")
 
  While exit_condition = 1
   
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C") * (-1)
    CurrentEncoder = s2
   
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
     
      If V > Vmax Then
        V = Vmax
      EndIf
     
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
   
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
       
        If V < V0 Then
          V = V0
        EndIf
       
      EndIf
    EndIf
   
    'PD controller for sync movement
   
    error = s1 + s2 'AM TE GAND SA OMOR UN COPIL COPAC ________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = -1 * (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
 
EndFunction

Function reverseMoveSyncCM_read(in number distance, in number V, in string end_brake,out number cubu1,out number cubu2,out number cubu3,out number cubu4)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  
  Motor.ResetCount("BC")
  Cm2Degrees(3, dist)
  Cm2Degrees(3.5, deg1)
  Cm2Degrees(10.5, deg2)
  Cm2Degrees(17.5, deg3)
  Cm2Degrees(25, deg4)
  Cm2Degrees(0, offset)
  v1[360] = 0
  v2[360] = 0
  v3[360] = 0
  v4[360] = 0
  stop1 = 0
  stop2 = 0
  stop3 = 0
  stop4 = 0
  start1 = 0
  start2 = 0
  start3 = 0
  start4 = 0
  Sensor.SetMode(3, 4)
  While exit_condition = 1
    
    
    
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C")
    CurrentEncoder = s2
    citire(col)
    if Math.Abs(CurrentEncoder) >= deg1 + offset and Math.Abs(CurrentEncoder) <= deg1 + dist + offset Then  
      'if(stop1 = 0)Then
        'stop1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v1[col]=v1[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg2 + offset and Math.Abs(CurrentEncoder) <= deg2 + dist + offset Then  
      'if(stop2 = 0)Then
        'stop2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v2[col]=v2[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg3 + offset and Math.Abs(CurrentEncoder) <= deg3 + dist + offset Then
      'if(stop3 = 0)Then
        'stop3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v3[col]=v3[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg4 + offset and Math.Abs(CurrentEncoder) <= deg4 + dist + offset Then
      'if(stop4 = 0)Then
        'stop4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v4[col]=v4[col]+1
    'Else 
       'if(start1 = 0 AND stop1 = 1)Then
        'start1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start2 = 0 AND stop2 = 1)Then
        'start2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start3 = 0 AND stop3 = 1)Then
        'start3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start4 = 0 AND stop4 = 1)Then
        'start4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
    EndIf  
   
    
    
    'PD controller for sync movement
   
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", -MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v1[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v1[i]
  EndFor   
  if(contor > 0)Then
    cubu1 = 3
  Else    
    cubu1 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v2[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v2[i]
  EndFor   
  if(contor > 0)Then
    cubu2 = 3
  Else    
    cubu2 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v3[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v3[i]
  EndFor   
  if(contor > 0)Then
    cubu3 = 3
  Else    
    cubu3 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v4[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v4[i]
  EndFor   
  if(contor > 0)Then
    cubu4 = 3
  Else     
    cubu4 = 2  
  EndIf
 
EndFunction

Function RotateTillWhite(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var=1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 > @grey + 20)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 > @grey + 20)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  Motor.Stop("BC","true")
EndFunction

Function RotateTillBlack(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var = 1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 < @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 < @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  Motor.Stop(@Stop_motor,"true")
  Program.Delay(100)
  Time.Reset1()
  time = 300
  error = 0
  error_old = 0
  error_sum = 0
  kp = 1
  kd = 0.1
  ki = 0.0001
  exit_condition = 1

  While exit_condition = 1
    s1 = sensor.ReadPercent(1)
    s2 = sensor.ReadPercent(2)
    s1=(s1/@MaximumWhiteSensor1)*100
    s2=(s2/@MaximumWhiteSensor2)*100
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    I = ki * error_sum
    Motor.StartPower(@left_motor,-((P + D + I)))
    Motor.StartPower(@right_motor,-((P + D + I)))
    error_old = error
    error_sum = error_sum + error
    If Time.Get1() > time Then
      exit_condition = 0
    EndIf
  EndWhile
  
  Motor.Stop("BC","true")
EndFunction

Function PerfectLine(in number speed,in string direction)
  'Program.Delay(2000)
  RotateTillWhite(speed,direction)
  'Program.Delay(2000)
  RotateTillBlack(speed,direction)
EndFunction

Function MoveSyncPtArcMove(in number speedLeft, in number speedRight,in number encoder,in string acceleration,in string deceleration,in string end_brake)
  
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    
    If acceleration = "on" Then
      speedL=(-left_encoder / @acceleration_encoder) * (speedLeft - @speed_0) + @speed_0
      speedR=(right_encoder / @acceleration_encoder) * (speedRight - @speed_0) + @speed_0
      If speedL > speedLeft Then
        speedL = speedLeft
      EndIf
      If speedR > speedRight Then
        speedR = speedRight
      EndIf
    Else  
      speedL = speedLeft
      speedR = speedRight
    EndIf
    If deceleration = "on" Then
      if (encoder + left_encoder) <= @deceleration_encoder Then
        speedL = ((encoder + left_encoder) / @deceleration_encoder) * (speedLeft - @speed_0) + @speed_0
        If speedL < @speed_0 Then
          speedL = @speed_0
        EndIf
      EndIf
      if (encoder - right_encoder) <= @deceleration_encoder Then
        speedR = ((encoder - right_encoder) / @deceleration_encoder) * (speedRight - @speed_0) + @speed_0
        If speedR < @speed_0 Then
          speedR = @speed_0
        EndIf
      EndIf
    EndIf
    
    Motor.StartPower(@left_motor,-speedL)
    Motor.StartPower(@right_motor,speedR)
    
    If -left_encoder > encoder Or right_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  
  Motor.Stop("BC","True")
  
  if right_encoder < encoder Then
    Speaker.Note(50, "C5", 1000)
  EndIf
  
  'while -left_encoder < encoder
    'left_encoder = Motor.GetCount(@left_motor)
    'If acceleration = "on" Then
      'speedL=(-left_encoder / @acceleration_encoder) * (speedLeft - @speed_0) + @speed_0
      'If speedL > speedLeft Then
        'speedL = speedLeft
      'EndIf
    'Else  
      'speedL = speedLeft
    'EndIf
    'If deceleration = "on" Then
      'if (encoder + left_encoder) <= @deceleration_encoder Then
        'speedL = ((encoder + left_encoder) / @deceleration_encoder) * (speedLeft - @speed_0) + @speed_0
        'If speedL < @speed_0 Then
          'speedL = @speed_0
        'EndIf
      'EndIf
    'EndIf
    'Motor.StartPower(@left_motor,-speedL)
  'EndWhile
  
  while right_encoder < encoder
    right_encoder = Motor.GetCount(@right_motor)
    If acceleration = "on" Then
      speedR=(right_encoder / @acceleration_encoder) * (speedRight - @speed_0) + @speed_0
      If speedR > speedRight Then
        speedR = speedRight
      EndIf
    Else  
      speedR = speedRight
    EndIf
    If deceleration = "on" Then
      if (encoder - right_encoder) <= @deceleration_encoder Then
        speedR = ((encoder - right_encoder) / @deceleration_encoder) * (speedRight - @speed_0) + @speed_0
        If speedR < @speed_0 Then
          speedR = @speed_0
        EndIf
      EndIf
    EndIf
    Motor.StartPower(@right_motor,speedR)
  EndWhile
  
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function ArcMove(in number radius, in number degrees, in number speed, in string direction)
  encoder = 2 * (radius + @robot_diameter / 2) / @wheel_diameter * degrees
  
  if(direction = "right")Then
    speedLeft = speed * -1
    speedRight = speed * (radius - @robot_diameter / 2) / (radius + @robot_diameter / 2)
  Else
    speedRight = speed 
    speedLeft = -1 * speed * (radius - @robot_diameter / 2) / (radius + @robot_diameter / 2)
  EndIf      
  
  Motor.MoveSync("BC", speedLeft, speedRight, encoder, "on")
  
EndFunction  

Function lf_cm_precision(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 1'1 4
  kd = 4
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_intersection_cu_cub(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.25
  kd = 0.5
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey And s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction