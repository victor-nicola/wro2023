@kp = 0.5
@kd = 0.1
@left_motor = "B"
@right_motor = "C"
@wheel_diameter = 6.24
@robot_diameter = 17.25 '-0.35 cm 
@white = 60' de modificat
@grey = 30' de modificat
@grey_rb = 30
@black = 9' de modificat
@Stop_motor = @left_motor + @right_motor
@acceleration_encoder = 400
@deceleration_encoder = 300
@speed_0 = 20
@wheel2sensor_distance = 9
@maxRed = 229
@maxGreen = 226
@maxBlue = 175
@global = 0
@MaximumWhiteSensor1=79' de modificat
@MaximumWhiteSensor2=83' de modificat
@TimeBetween = 300
@degA = 0
@degD = 0
@auxD = 0
@kpD = 0.5
@optimumval = 69
@contor_error = 5
@stegulet_pervers = 0

Function CircleDegToMotorDeg( in number deg, out number motorDeg )
  motorDeg = deg * @robot_diameter / @wheel_diameter
EndFunction

Function MotorDegToCircleDeg( in number motorDeg, out number deg )
  deg = motorDeg * @wheel_diameter / @robot_diameter
EndFunction

Sub Claw
  error_oldA = 0
  kpA = 0.3
  kdA = 0.1
  error_oldD = 0
  @kpD = 0.5
  kdD = 0.1
  @degA = 0
  @degD = 0
  Motor.ResetCount("DA")
  While(1 = 1)
    encoder = Motor.GetCount("A")
    error = degA - encoder
    err1 = degA - encoder
    PA = error * kpA
    DA = (error - error_oldA) * kdA
    error_oldA = error
    Motor.StartPower("A",PA + DA)
    encoder = Motor.GetCount("D")
    error = degD - encoder
    err2 = degD - encoder
    @auxD = encoder
    PD = error * kpD
    DD = (error - error_oldD) * kdD
    error_oldD = error
    Motor.StartPower("D",PD + DD)
    if(err1 < 10 And err1 > -10 And err2 < 10 And err2 > -10 )Then
      @stegulet_pervers = 0
    EndIf
  EndWhile
EndSub

'A motor mediu de prindere
'D motor mare de invartire

Sub wait_claw
  Time.Reset1()
  @stegulet_pervers = 1
  While Time.Get1() < @TimeBetween 'And @stegulet_pervers = 1
    
  EndWhile
EndSub

sub raiseLift
  @kpD = 5
  @degD = 130
  wait_claw()
EndSub

sub raiseLiftalittle
  @kpD = 5
  @degD = @auxD-10
  wait_claw()
EndSub

sub aslowaspossible
  @kpD = 0.3
  @degD = 200
  wait_claw()
  wait_claw()
EndSub

sub raiseLiftsuper
  @kpD = 5
  @degD = 110
  wait_claw()
EndSub

Sub lowerLift
  @kpD = 0.6
  @degD = 200'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

Sub lowerLiftslow
  @kpD = 0.4
  @degD = 200'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
  wait_claw()
  wait_claw()
EndSub

Sub lowerLiftsLowAndLower
  @kpD = 0.4
  @degD = 230'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
  wait_claw()
  wait_claw()
  wait_claw()
  wait_claw()
EndSub

Sub lowerLiftSpecialCube
  @kpD = 0.6
  @degD = 152
  wait_claw()
EndSub

Sub lowerLiftSpecialCubePut
  @kpD = 4
  @degD = 145'se coboara(*urca acum ca suntem smecheri) la unghiul optim ca sa punem speciala
  wait_claw()
EndSub

sub lowerLiftToLittleShip
  @kpD = 0.4
  @degD = 190
  wait_claw()
  wait_claw()
  wait_claw()

EndSub

sub lowerLiftToBigShip
  @kpD = 0.4
  @degD = 173
  wait_claw()
  wait_claw()
  wait_claw()

EndSub

sub destroyFlagLittleShipOne
  @kpD = 0.5
  @degD = 128.5
  wait_claw()
  wait_claw()  
  'wait_claw()  
  'wait_claw()   
EndSub

sub destroyFlagLittleShipTwo
  @kpD = 1
  @degD = 143
  '@degA = 80
  wait_claw()  
  wait_claw()  
  wait_claw()  
  'wait_claw()  
  'wait_claw()  
  'RobotSpin("right",30 ,100, "off", "off", "off")
  'RobotSpin("left",30 ,100, "off", "off", "on")  
EndSub


sub resetLift
  @kpD = 0.5
  @degD = 0
  wait_claw()
EndSub

Sub prepLowerLiftSpecialCube
  @degA = -120
  wait_claw()
EndSub

Sub closeClaw
  @degA = -250
  wait_claw()
  @degA = -500 ' de modificat
EndSub

sub resetArm
  @degA = 0
  @degD = 10
  wait_claw()
EndSub

sub resetClaw
  @degA = 0
  wait_claw()
EndSub

sub clawForWhite
  
  @degA = -110
  wait_claw()
  
EndSub


sub prepForWhite
  @degA = -120
  wait_claw()
  wait_claw()
  @kpD = 0.6
  @degD = 180'se coboara la unghiul optim ca sa luam cuburile
  wait_claw()
EndSub

Sub prepForGreen1
  @degA = -130
  wait_claw()
EndSub

Sub prepForGreen
  @degA = -125
  wait_claw()
EndSub

sub letALittleMore
  @degA = -115
  wait_claw()
  wait_claw()
EndSub

sub letALittle
  @degA = -130
  wait_claw()
  wait_claw()
EndSub

sub letALittleMedium
  @degA = -132
  wait_claw()
  wait_claw()
EndSub

sub letALot
  @degA = -80
  wait_claw()
  wait_claw()
EndSub

sub letALittleless
  @degA = -135
  wait_claw()
  wait_claw()
EndSub

sub putGreenOnShip
  @kpD = 0.6
  @degD = 145
  wait_claw()
  wait_claw()
 letALittleless()
EndSub

sub putWhiteOnShip
  @kpD = 0.8
  @degD = 152
  wait_claw()
  wait_claw()
  wait_claw()
  letALittleless()
EndSub

sub putGreenOnSmallShip
  @kpD = 0.8
  @degD = 140
  wait_claw()
  wait_claw()
  letALittleless()
EndSub

sub putWhiteOnSmallShip
  @kpD = 0.6
  @degD = 140
  wait_claw()
  wait_claw()
  letALittle()
EndSub

Function ceSaUrmaresti(in number case, in number a, in number b, in number c, in number d, out number follow)
  'case
  '1 - 2 verde
  '2 - 2 albastru
  '3 - mixt
  follow = -1
  If case = 1 Then
    If b = 3 And c = 3 Then
      follow = 1
    Else 
      If c = 3 And d = 3 Then
        follow = 0
      Else 
        If a = 3 And b = 3 Then
          follow = 2
        EndIf
      EndIf
    EndIf
  Else 
    If case = 2 Then
      If b = 2 And c = 2 Then
        follow = 1
      Else 
        If c = 2 And d = 2 Then
          follow = 0
        Else
          If a = 2 And b = 2 Then
            follow = 2
          EndIf
        EndIf
      EndIf
    
    Else 
      If case = 3 Then
        If b + c = 5 Then
          follow = 1              
        Else 
          If c + d = 5 Then
            follow = 0
          Else 
            If a + b = 5 Then
              follow = 2
            EndIf
          EndIf
        EndIf
      EndIf  
    EndIf
  EndIf
EndFunction

Function stangadreata(in number cm, in number v, in string sens)
  
  gr = Math.ArcCos((1 - (cm / 17.25))) * (17.25 / @wheel_diameter) * (180 / Math.Pi)
  MotorDegToCircleDeg(gr,codex)
  
  if sens = "left" Then
    spinDegrees(v, "right",codex, "off", "off", "on")
    Program.Delay(100)
    spinDegrees(v, "left",codex, "off", "off", "on")
    Program.Delay(100)

  Else
    spinDegrees(v, "left",codex, "off", "off", "on")
    Program.Delay(100)
    spinDegrees(v, "right",codex, "off", "off", "on")
    Program.Delay(100)
  EndIf
  
EndFunction

Function lf_intersection(in number speed_max,in string acceleration,in string deceleration,in string end_brake)
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  If deceleration = "on" Then
    Motor.ResetCount(@stop_motor)
    exit_condition = 1
    Cm2Degrees(@wheel2sensor_distance,encoder)
    While exit_condition = 1
      left_encoder = Motor.GetCount(@left_motor)
      right_encoder = Motor.GetCount(@right_motor)
      left_encoder = -1 * left_encoder
      current_encoder = (left_encoder + right_encoder) / 2
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
      Motor.StartPower(@left_motor,-speed)
      Motor.StartPower(@right_motor,speed)
      If current_encoder >= encoder Then
        exit_condition = 0
      EndIf
    EndWhile
  EndIf
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function lf_intersection_read_col(in number speed_max,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  Cm2Degrees(3.5,prim_st)
  Cm2Degrees(6,prim_dr)
  Cm2Degrees(8.5,doi_st)
  Cm2Degrees(10.5,doi_dr)
  
  frec[360] = 0
  
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  error_old = 0
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
     If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,speed - (P + D))
    error_old = error
    If s1 < @grey Or s2 < @grey Then
      exit_condition = 0
    EndIf
  EndWhile
  deg = current_encoder
  
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(6,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1 
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    
    if((current_encoder+deg>=prim_st AND current_encoder+deg<=prim_dr) OR (current_encoder+deg>=doi_st AND current_encoder+deg<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")       
    EndIf
    
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  'handle = EV3File.OpenWrite("vectorfrecventa")
  'i = 0
  'final = " "
  'While i < 100
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 200
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 300
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)
  'final = " "
  'While i < 360
    'a = frec[i]
    'aux = Text.Append(a, " ")
    'final = Text.Append(final, aux)
    'i = i + 1
  'EndWhile
  'EV3File.WriteLine(handle, final)

EndFunction

Function lf_cm_read_col(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake,out number type)
  
  Cm2Degrees(8.5,prim_st)
  Cm2Degrees(11,prim_dr)
  Cm2Degrees(13.5,doi_st)
  Cm2Degrees(15.5,doi_dr)
  
  frec[360] = 0
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    
    if((current_encoder>=prim_st AND current_encoder<=prim_dr) OR (current_encoder>=doi_st AND current_encoder<=doi_dr))Then
      citire(hue)
      frec[hue] = frec[hue] + 1
      EV3.SetLEDColor("RED","NORMAL")
    Else  
      EV3.SetLEDColor("GREEN","NORMAL")     
    EndIf
    
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
  
  
  type=0
  contor = 0 
  for i=90 to 210 ' verde
    contor = contor + frec[i]
  EndFor  
  'LCD.Write(10,10,contor)
  if(contor > @contor_error)Then
    type = 1' verde * 2
  EndIf     
  contor = 0 
  for i=211 to 270'albastru
    contor = contor + frec[i]
  EndFor   
  'LCD.Write(30,10,contor)
  if(contor > @contor_error)Then
    if(type = 1)Then
      type = 3'albasrru + verde
    Else    
      type = 2'albastru * 2
    EndIf
  EndIf    
  
EndFunction

Function lf_cm(in number speed_max,in number cm,in string acceleration,in string deceleration,in string end_brake)
  
  kp = 0.5
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0
  flag = 1
  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    left_encoder=left_encoder*-1
    current_encoder = (left_encoder + right_encoder) / 2
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    If acceleration = "on" Then
      speed=(current_encoder / @acceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed > speed_max Then
        speed = speed_max
      EndIf
    Else  
      speed = speed_max
    EndIf
    If deceleration = "on" And (encoder - current_encoder) <= @deceleration_encoder Then
      speed = ((encoder - current_encoder) / @deceleration_encoder) * (speed_max - @speed_0) + @speed_0
      If speed < @speed_0 Then
        speed = @speed_0
      EndIf
    EndIf
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function Cm2Degrees(in number cm,out number degrees)
  degrees = (360*cm) / (Math.Pi*@wheel_diameter)
EndFunction

Function RobotSpin(in string direction,in number degrees,in number speed,in string acceleration, in string deceleration, in string end_brake)  
  if direction = "left" Then
    side = 1
  else 
    side = -1
  EndIf
  
  'left is side = 1 and right is side = -1
  '------
  kp = 1
  kd = 0.1
  V0 = 20
  '------
  errorOld = 0
  '------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  circleDegToMotorDeg(degrees, encoder)
  
  
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 750
  If 0.75 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.75 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  
  exit = 0
  While exit <> 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    currentEncoder = (Math.Abs(r1) + Math.Abs(r2)) / 2
    'r1 is the left engine, and r2 is the right engine
    error = Math.Abs(r2) - Math.Abs(r1)
    P = kp * error
    D = kd * (error - errorOld)
    errorOld = error
    
    LCD.Clear()
    LCD.Text(0, 1, 1, 2, currentEncoder)
    LCD.Update()
    
    V = speed
    If acceleration = "on" AND  currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (speed - V0) + V0
      If V > speed Then
        V = speed
      EndIf
    EndIf
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        Speaker.Tone(70, 5000, 100)
        V = ((encoder - currentEncoder) / decelerationEncoder) * (speed - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf  
    
    
    motorB = V + (P + D)
    motorC = V - (P + D)
    
    If exit <> 1 Then
      Motor.StartPower( "B", motorB * side )
      Motor.StartPower( "C", motorC * side )
    EndIf
    
    'errorLast = error
    If currentEncoder >= encoder Then
      exit = 1
    EndIf
   
  EndWhile
 
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  'Program.Delay(200)
 
EndFunction

Function Rotation2Black(in string direction,in number speed,in string end_break)
  Sensor.SetMode(1,0)
  sensor.SetMode(2,0)
  If direction = "right" Then
    s2 = sensor.ReadPercent(2)
    While s2 > @grey_rb
      Motor.StartSync(@Stop_motor,-speed,-speed)
      s2 = sensor.ReadPercent(2)
    EndWhile
    Motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s1 - s2
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,-((P + D + I)))
      Motor.StartPower(@right_motor,-((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  Else
    s1 = sensor.ReadPercent(1)
    While s1 > @grey_rb
      Motor.StartSync(@Stop_motor,speed,speed)
      s1 = sensor.ReadPercent(1)
    EndWhile
    motor.Stop(@Stop_motor,"true")
    Time.Reset1()
    time = 300
    error = 0
    error_old = 0
    error_sum = 0
    kp = 1
    kd = 0.5
    ki = 0.0001
    exit_condition = 1
    While exit_condition = 1
      s1 = sensor.ReadPercent(1)
      s2 = sensor.ReadPercent(2)
      s1=(s1/@MaximumWhiteSensor1)*100
      s2=(s2/@MaximumWhiteSensor2)*100
      error = s2 - s1
      P = kp * error
      D = kd * (error - error_old)
      I = ki * error_sum
      Motor.StartPower(@left_motor,((P + D + I)))
      Motor.StartPower(@right_motor,((P + D + I)))
      error_old = error
      error_sum = error_sum + error
      If Time.Get1() > time Then
        exit_condition = 0
      EndIf
    EndWhile
    If end_break = "on" Then
      Motor.Stop(@Stop_motor,"true")
    EndIf
  EndIf
EndFunction

Function MoveSync(in number speed_max,in number cm,in string end_brake)
  kp = @kp
  kd = @kd
  exit_condition = 1
  Motor.ResetCount(@stop_motor)
  left_encoder = 0
  right_encoder = 0
  Cm2Degrees(cm,encoder)
  error_old = 0

  While exit_condition = 1
    left_encoder = Motor.GetCount(@left_motor)
    right_encoder = Motor.GetCount(@right_motor)
    current_encoder = ((-1*left_encoder) + right_encoder) / 2
    error = left_encoder + right_encoder
    P = kp * error
    D = kd * (error - error_old)
    speed=speed_max
    Motor.StartPower(@left_motor,-(speed + (P + D)))
    Motor.StartPower(@right_motor,(speed - (P + D)))
    error_old = error
    If current_encoder > encoder Then
      exit_condition = 0
    EndIf
  EndWhile
  If end_brake = "on" Then
    Motor.Stop("BC","True")
  EndIf
EndFunction

Function ReactiveBreakingPerversaDeStangaStraightAlley(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 200
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
  Motor.ResetCount(port[side])
  while enc < 150
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
  Sensor.SetMode(2-side, 0)
  s2 = Sensor.ReadPercent(2-side)
  while s2 < @grey
    Motor.StartPower(port[2-side], vit * mult)
    s2 = Sensor.ReadPercent(2-side)
  EndWhile
  
  Sensor.SetMode(side, 0)
  s1 = Sensor.ReadPercent(side)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side)
  EndWhile
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
 
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  'Motor.Stop("BC", "True")
  'Program.Delay(1000)
  
EndFunction

Function ReactiveBreakingPerversaDeDreaptaStraightAlley(in number vit)
  port[0] = "C"
  port[1] = "B"
  side = 1
  mult = -1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 100 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
 
  
  'Sensor.SetMode(2 - side, 0)
  's2 = Sensor.ReadPercent(2 - side)
  'while s2 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's2 = Sensor.ReadPercent(2 - side)
  'EndWhile
  
  
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Motor.Stop("BC", "True")
EndFunction

Function ReactiveBreakingIntersectionCuburi(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 100
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  
  Motor.Stop(port[1 - side], "True")
  while enc < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 > @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile

EndFunction

Function ReactiveBreakingIntersectionStanga(in number vit)
  port[0] = "C"
  port[1] = "B"
  
  side = 0
  mult = 1
  
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  
  Motor.Stop(port[1 - side], "True")
  while enc * mult < 300
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
  
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile
EndFunction

Function ReactiveBreakingIntersectionDreapta(in number vit)
  port[0] = "C"
  port[1] = "B"
  side = 1
  mult = -1
  enc = 0
  Time.Reset5()
  timer = Time.Get5()
  
  while timer < 10 
    Motor.StartPower(port[1 - side], vit * mult)
    Motor.StartPower(port[side], vit * mult)
    timer = Time.Get5()
  EndWhile
  Motor.Stop(port[1 - side], "True")
 
  while enc * mult < 150
    Motor.StartPower(port[side], vit * mult)
    enc = Motor.GetCount(port[side])
  EndWhile
  
  
  Sensor.SetMode(2 - side, 0)
  s2 = Sensor.ReadPercent(2 - side)
  while s2 < @grey
    Motor.StartPower(port[side], vit * mult)
    s2 = Sensor.ReadPercent(2 - side)
  EndWhile
 
  
  'Sensor.SetMode(2 - side, 0)
  's2 = Sensor.ReadPercent(2 - side)
  'while s2 > @grey
    'Motor.StartPower(port[side], vit * mult)
    's2 = Sensor.ReadPercent(2 - side)
  'EndWhile
  
  
  'Sensor.SetMode(side + 1, 0)
  's1 = Sensor.ReadPercent(side + 1)
  'while s1 < @grey
    'Motor.StartPower(port[side], vit * mult)
    's1 = Sensor.ReadPercent(side + 1)
  'EndWhile 
  
  Sensor.SetMode(side + 1, 0)
  s1 = Sensor.ReadPercent(side + 1)
  while s1 > @grey
    Motor.StartPower(port[side], vit * mult)
    s1 = Sensor.ReadPercent(side + 1)
  EndWhile 
  'Motor.Stop("BC", "True")
EndFunction

Function spinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  
  ' ----------
  v0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  encoder = circleDegrees * 2 * @robot_diameter / @wheel_diameter
  accelerationEncoder = 100
  If 0.1 * encoder < accelerationEncoder Then
    accelerationEncoder = 0.1 * encoder
  EndIf
  decelerationEncoder = 750
  If 0.75 * encoder < decelerationEncoder Then
    decelerationEncoder = 0.75 * encoder
  EndIf
  
  Motor.ResetCount("BC")
  While exitCondition = 1
   
    r1 = Motor.GetCount(@left_motor)
    r2 = Motor.GetCount(@right_motor)
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    V = Vmax
    If acceleration = "on" AND  currentEncoder < accelerationEncoder Then
      V = (currentEncoder / accelerationEncoder) * (Vmax - V0) + V0
      If V > Vmax Then
        V = Vmax
      EndIf
    EndIf
    If deceleration = "on" Then 
      If currentEncoder >= encoder - decelerationEncoder Then
        Speaker.Tone(70, 5000, 100)
        V = ((encoder - currentEncoder) / decelerationEncoder) * (Vmax - V0) + V0
        If V < V0 Then
          V = V0
        EndIf
      EndIf
    EndIf  
   
    If side = "right" Then
      Motor.StartPower("C", V)
    Else
      Motor.StartPower("B", V * -1)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
   
  EndWhile
 
  If endBrake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else
    
    Motor.Stop("BC", "False")
  
  EndIf
 
EndFunction

Function reverseSpinDegrees(in number Vmax, in string side, in number circleDegrees, in string acceleration, in string deceleration, in string endBrake)
  ' ----------
  V0 = @speed_0
  ' ----------
  errorOld = 0
  exitCondition = 1
  ' ----------
  diamAx = @robot_diameter
  diamRoata = @wheel_diameter
  encoder = circleDegrees * 2 * diamAx / diamRoata
 
 
  Motor.ResetCount("BC")
 
  While exitCondition = 1
   
    r1 = Motor.GetCount("B")
    r2 = Motor.GetCount("C")
   
    ' r1 is the left engine, and r2 is the right engine
   
    If side = "right" Then
      currentEncoder = Math.Abs(r2)
    Else
      currentEncoder = Math.Abs(r1)
    EndIf
   
    If currentEncoder < @acceleration_encoder Then
     
      If acceleration = "on" Then
        V = (currentEncoder / @acceleration_encoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier increases as the robot gets closer to the acceleration quota
      Else
        V = Vmax  
      EndIf
     
    EndIf
   
    If encoder - currentEncoder < @deceleration_encoder Then
     
      If deceleration = "on" Then
        V = ((encoder - currentEncoder) / @deceleration_encoder) * (Vmax - V0) + V0
        V = Math.Abs(V)
        'multiplier decreases as the robot gets closer to the deceleration quota
      Else
        V = Vmax
      EndIf
     
    EndIf
   
    If side = "right" Then
      Motor.StartPower("C", V * -1)
    Else
      Motor.StartPower("B", V)
    EndIf

    If currentEncoder > encoder Then
      exitCondition = 0
    EndIf
   
  EndWhile
 
  If endBrake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
EndFunction

Function citire(out number col)
   red = 0
  green = 0
  blue = 0
  @max_R = @maxRed
  @max_G = @maxGreen
  @max_B = @maxBlue
  Sensor3.Raw3(red, green, blue)
  red = red / @max_R * 255
  green = green / @max_G * 255
  blue = blue / @max_B * 255
 
  max = Math.Max(red, green)
  max = Math.Max(max, blue)
  min = Math.Min(red, green)
  min = Math.Min(min, blue)
  'max = 323
  'min = 182
 
  @r = red
  @g = green
  @b = blue
  If max = min Then
    hue = 0
  EndIf
  If max=@r Then
    If @g>=@b Then
      hue = 60*(@g-@b)/(max-min)
    Else
      hue = 60*(@g-@b)/(max-min)+360
    EndIf
  ElseIf max = @g Then
    hue = 60*(@b-@r)/(max-min)+120
  ElseIf max = @b Then
    hue = 60*(@r-@g)/(max-min)+240
  EndIf
 
  If max = 0 Then
    sat = 0
  Else
    sat = 1-min/max
  EndIf
 
  val = max / 255
  
  if(sat >= 0.56)Then
    col = hue  
  Else    
    col = 0   
  EndIf
  
EndFunction

Function MoveTillBlack(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 < @grey And s2 < @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function MoveTillWhite(in number speed,in string break)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,-speed)
    Motor.StartPower(@right_motor,speed)    
    if(s1 > @grey And s2 > @grey)Then
      exit_condition = 0
    EndIf
  EndWhile
  if(break = "true") Then
    Motor.Stop("BC","true")
  EndIf
EndFunction

Function StraightAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSync(@speed_movesync,0.5,"on")

EndFunction

Function GayAlley(in number speed)
  MoveTillWhite(speed,"false")
  MoveTillBlack(speed,"false")
  MoveSync(70, 3, "on")
EndFunction

Function reverseMoveSyncCM(in number distance, in number Vmax, in string acceleration, in string deceleration, in string end_brake)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  V0 = @speed_0
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  If encoder > 1000 Then
    
    AcceleratedEncoder = @acceleration_encoder
    DeceleratedEncoder = @deceleration_encoder
    
  Else
    
    AcceleratedEncoder = encoder * 0.1
    DeceleratedEncoder = encoder * 0.1
    
  EndIf
  
  Motor.ResetCount("BC")
 
  While exit_condition = 1
   
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C") * (-1)
    CurrentEncoder = s2
   
    'acceleration algorithm for smooth start
    If acceleration = "on" Then
      V = ( CurrentEncoder / AcceleratedEncoder ) * ( Vmax - V0 ) + V0
      V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
     
      If V > Vmax Then
        V = Vmax
      EndIf
     
    ElseIf acceleration = "off" Then
      V = Vmax
    EndIf
   
    'deceleation for smooth stop
    If deceleration = "on" Then
      If encoder - CurrentEncoder < DeceleratedEncoder Then 'we must get the last part of the encoder run
        V = ( (encoder - CurrentEncoder) / DeceleratedEncoder ) * ( Vmax - V0 ) + V0
        V = Math.Abs( V ) 'needed to make sure the robot will not go backwards
       
        If V < V0 Then
          V = V0
        EndIf
       
      EndIf
    EndIf
   
    'PD controller for sync movement
   
    error = s1 + s2 'AM TE GAND SA OMOR UN COPIL COPAC ________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = -1 * (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
 
EndFunction


Function reverseMoveSyncCM_read(in number distance, in number V, in string end_brake,out number cubu1,out number cubu2,out number cubu3,out number cubu4)
 
  '------ These values might be adjusted for light or specs
  grey = @grey
  kp = @kp
  kd = @kd
  '------
  pi = Math.Pi
  diameter = @wheel_diameter
  encoder = 360 * distance / pi / diameter
  error_old = 0
  exit_condition = 1
  
  
  Motor.ResetCount("BC")
  Cm2Degrees(3, dist)
  Cm2Degrees(3, deg1)
  Cm2Degrees(10, deg2)
  Cm2Degrees(17, deg3)
  Cm2Degrees(24.5, deg4)
  Cm2Degrees(-1, offset)
  v1[360] = 0
  v2[360] = 0
  v3[360] = 0
  v4[360] = 0
  stop1 = 0
  stop2 = 0
  stop3 = 0
  stop4 = 0
  start1 = 0
  start2 = 0
  start3 = 0
  start4 = 0
  Sensor.SetMode(3, 4)
  While exit_condition = 1
    
    
    
    'read the sensors only one time in the loop!
    s1 = Motor.GetCount("B") * (-1)
    s2 = Motor.GetCount("C")
    CurrentEncoder = s2
    citire(col)
    if Math.Abs(CurrentEncoder) >= deg1 + offset and Math.Abs(CurrentEncoder) <= deg1 + dist + offset Then  
      'if(stop1 = 0)Then
        'stop1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v1[col]=v1[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg2 + offset and Math.Abs(CurrentEncoder) <= deg2 + dist + offset Then  
      'if(stop2 = 0)Then
        'stop2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v2[col]=v2[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg3 + offset and Math.Abs(CurrentEncoder) <= deg3 + dist + offset Then
      'if(stop3 = 0)Then
        'stop3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v3[col]=v3[col]+1
    ElseIf Math.Abs(CurrentEncoder) >= deg4 + offset and Math.Abs(CurrentEncoder) <= deg4 + dist + offset Then
      'if(stop4 = 0)Then
        'stop4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      v4[col]=v4[col]+1
    'Else 
       'if(start1 = 0 AND stop1 = 1)Then
        'start1 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start2 = 0 AND stop2 = 1)Then
        'start2 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start3 = 0 AND stop3 = 1)Then
        'start3 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
      'if(start4 = 0 AND stop4 = 1)Then
        'start4 = 1
        'Motor.Stop("BC","true")
        'Program.Delay(1000)
      'EndIf
    EndIf  
   
    
    
    'PD controller for sync movement
   
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    MotorB = (V + (P + D) )
    MotorC = (V - (P + D))
    error_old = error
   
    Motor.StartPower("B", MotorB)
    Motor.StartPower("C", -MotorC)
   
    'exit condition for line follower: encoder
    If Math.Abs(CurrentEncoder) > encoder Then
      exit_condition = 0
    EndIf
   
  EndWhile
 
  'check if we want brake at the end of the linefollower
  If end_brake = "on" Then
    
    Motor.Stop("BC", "True")
    
  Else  
    
    Motor.Stop("BC", "False")
    
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v1[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v1[i]
  EndFor   
  if(contor > 0)Then
    cubu1 = 3
  Else    
    cubu1 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v2[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v2[i]
  EndFor   
  if(contor > 0)Then
    cubu2 = 3
  Else    
    cubu2 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v3[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v3[i]
  EndFor   
  if(contor > 0)Then
    cubu3 = 3
  Else    
    cubu3 = 2  
  EndIf
  
  contor = 0 
  for i=90 to 210  'verde
    contor = contor + v4[i]
  EndFor  
  for i=211 to 270 'albastru
    contor = contor - v4[i]
  EndFor   
  if(contor > 0)Then
    cubu4 = 3
  Else     
    cubu4 = 2  
  EndIf
 
EndFunction

Function RotateTillWhite(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = -1
    sens = 1
  Else   
    var=1  
    sens = 2
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 > @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 > @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  Motor.Stop("BC","true")
EndFunction

Function RotateTillBlack(in number speed,in string direction)
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,0)
  exit_condition = 1
  
  if(direction = "right")Then
    var = 1
    sens = 2
  Else   
    var=-1  
    sens = 1
  EndIf
  
  While exit_condition = 1
    s1 = Sensor.ReadPercent(1)
    s2 = Sensor.ReadPercent(2)
    Motor.StartPower(@left_motor,speed*var)
    Motor.StartPower(@right_motor,speed*var)
    if(sens = 1)Then
      if(s1 < @grey)Then
        exit_condition = 0
      EndIf
    Else    
      if(s2 < @grey)Then
        exit_condition = 0
      EndIf  
    EndIf
  EndWhile
  
  Motor.Stop(@Stop_motor,"true")
  Time.Reset1()
  time = 100
  error = 0
  error_old = 0
  error_sum = 0
  kp = 1
  kd = 0.5
  ki = 0.0001
  exit_condition = 1
  While exit_condition = 1
    s1 = sensor.ReadPercent(1)
    s2 = sensor.ReadPercent(2)
    s1=(s1/@MaximumWhiteSensor1)*100
    s2=(s2/@MaximumWhiteSensor2)*100
    error = s1 - s2
    P = kp * error
    D = kd * (error - error_old)
    I = ki * error_sum
    Motor.StartPower(@left_motor,-((P + D + I)))
    Motor.StartPower(@right_motor,-((P + D + I)))
    error_old = error
    error_sum = error_sum + error
    If Time.Get1() > time Then
      exit_condition = 0
    EndIf
  EndWhile
  
  Motor.Stop("BC","true")
EndFunction

Function PerfectLine(in number speed,in string direction)
  RotateTillWhite(speed,direction)
  RotateTillBlack(speed,direction)
EndFunction